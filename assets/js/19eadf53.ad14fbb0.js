"use strict";(self.webpackChunkpy_tfhe_oss_doc=self.webpackChunkpy_tfhe_oss_doc||[]).push([[7981],{2356:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"submodules/pytfhe-frontend/overview","title":"PyTFHE-Frontend Overview","description":"Introduction","source":"@site/docs/submodules/pytfhe-frontend/overview.md","sourceDirName":"submodules/pytfhe-frontend","slug":"/submodules/pytfhe-frontend/overview","permalink":"/pytfhe/docs/submodules/pytfhe-frontend/overview","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/submodules/pytfhe-frontend/overview.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"PyTFHE-Frontend","permalink":"/pytfhe/docs/category/pytfhe-frontend"},"next":{"title":"XLS IR to TASM Converter","permalink":"/pytfhe/docs/submodules/pytfhe-frontend/xls-bridge"}}');var s=i(4848),t=i(8453);const l={sidebar_position:1},o="PyTFHE-Frontend Overview",c={},a=[{value:"Introduction",id:"introduction",level:2},{value:"Project Architecture",id:"project-architecture",level:2},{value:"High-Level Design",id:"high-level-design",level:3},{value:"Core Data Flow",id:"core-data-flow",level:3},{value:"Supported Circuit Formats",id:"supported-circuit-formats",level:2},{value:"AIGER Format",id:"aiger-format",level:3},{value:"XLS Intermediate Representation",id:"xls-intermediate-representation",level:3},{value:"TASM Binary Format",id:"tasm-binary-format",level:3},{value:"Execution Backends",id:"execution-backends",level:2},{value:"CPU Execution",id:"cpu-execution",level:3},{value:"GPU Execution",id:"gpu-execution",level:3},{value:"Alternative Backends",id:"alternative-backends",level:3},{value:"Development Workflow",id:"development-workflow",level:2},{value:"Circuit Development Pipeline",id:"circuit-development-pipeline",level:3},{value:"Testing Strategy",id:"testing-strategy",level:3},{value:"Performance Characteristics",id:"performance-characteristics",level:2},{value:"Scalability Factors",id:"scalability-factors",level:3},{value:"Optimization Strategies",id:"optimization-strategies",level:3},{value:"Installation and Setup",id:"installation-and-setup",level:2},{value:"Prerequisites",id:"prerequisites",level:3},{value:"Backend Configuration",id:"backend-configuration",level:3},{value:"Common Usage Patterns",id:"common-usage-patterns",level:2},{value:"Basic Circuit Execution",id:"basic-circuit-execution",level:3},{value:"Circuit Format Conversion",id:"circuit-format-conversion",level:3},{value:"Simulation and Testing",id:"simulation-and-testing",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"pytfhe-frontend-overview",children:"PyTFHE-Frontend Overview"})}),"\n",(0,s.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsx)(n.p,{children:"PyTFHE-Frontend is a comprehensive Python framework for Fully Homomorphic Encryption (FHE) circuit execution. It serves as the frontend interface for PyTFHE libraries, providing scheduling, assembly, and execution capabilities for encrypted computations. The project enables developers to run complex Boolean circuits on encrypted data while maintaining cryptographic security."}),"\n",(0,s.jsx)(n.h2,{id:"project-architecture",children:"Project Architecture"}),"\n",(0,s.jsx)(n.h3,{id:"high-level-design",children:"High-Level Design"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Circuit Input \u2502    \u2502   Scheduling    \u2502    \u2502   Execution     \u2502\n\u2502                 \u2502    \u2502                 \u2502    \u2502                 \u2502\n\u2502 \u2022 AIGER Format  \u2502\u2500\u2500\u2500\u25b6\u2502 \u2022 Greedy        \u2502\u2500\u2500\u2500\u25b6\u2502 \u2022 CPU (Serial)  \u2502\n\u2502 \u2022 XLS IR        \u2502    \u2502 \u2022 LUT-based     \u2502    \u2502 \u2022 CPU (Ray)     \u2502\n\u2502 \u2022 Binary TASM   \u2502    \u2502 \u2022 Dependency    \u2502    \u2502 \u2022 GPU (CUDA)    \u2502\n\u2502                 \u2502    \u2502   Resolution    \u2502    \u2502                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,s.jsx)(n.h3,{id:"core-data-flow",children:"Core Data Flow"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Circuit Loading"}),": Import circuits from various formats (AIGER, XLS IR, TASM binary)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Graph Representation"}),": Convert to NetworkX-based AigerGraph objects"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Scheduling"}),": Generate execution order using dependency-aware algorithms"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Execution"}),": Run on CPU (serial/distributed) or GPU with FHE operations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Result Collection"}),": Decrypt and return computed outputs"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"supported-circuit-formats",children:"Supported Circuit Formats"}),"\n",(0,s.jsx)(n.h3,{id:"aiger-format",children:"AIGER Format"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Purpose"}),": Standard format for And-Inverter Graphs"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Usage"}),": Circuit specification and interchange"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"File Extension"}),": ",(0,s.jsx)(n.code,{children:".aag"})," (ASCII), ",(0,s.jsx)(n.code,{children:".aig"})," (binary)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Processing"}),": Parsed into NetworkX graphs via ",(0,s.jsx)(n.code,{children:"aiger_tools"})]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"xls-intermediate-representation",children:"XLS Intermediate Representation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Purpose"}),": Google's XLS hardware synthesis tool output"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Usage"}),": High-level synthesis to Boolean circuits"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"File Extension"}),": ",(0,s.jsx)(n.code,{children:".bool.ir"})," (boolean-optimized IR)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Processing"}),": Converted to TASM via ",(0,s.jsx)(n.code,{children:"xls_ir2tasm"})]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"tasm-binary-format",children:"TASM Binary Format"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Purpose"}),": Optimized binary format for FHE execution"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Usage"}),": Direct input to execution engines"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"File Extension"}),": ",(0,s.jsx)(n.code,{children:".tasm"})," (optionally gzip compressed)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Processing"}),": Native format for ",(0,s.jsx)(n.code,{children:"runner"})," modules"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"execution-backends",children:"Execution Backends"}),"\n",(0,s.jsx)(n.h3,{id:"cpu-execution",children:"CPU Execution"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Serial Mode"}),": Single-threaded execution for debugging and small circuits"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Ray Distributed"}),": Multi-worker parallel execution across CPU cores/machines"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Library"}),": pyTFHE (CPU-optimized FHE operations)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use Cases"}),": Development, testing, moderate-scale computation"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"gpu-execution",children:"GPU Execution"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"CUDA Acceleration"}),": High-performance GPU execution"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Batch Processing"}),": Configurable batch sizes for memory optimization"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Library"}),": pyTFHEGPU (CUDA-accelerated FHE operations)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use Cases"}),": Large-scale computation, high-throughput applications"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"alternative-backends",children:"Alternative Backends"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"cuFHE Integration"}),": Alternative GPU FHE library support"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Hybrid Execution"}),": Combining CPU and GPU resources"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"development-workflow",children:"Development Workflow"}),"\n",(0,s.jsx)(n.h3,{id:"circuit-development-pipeline",children:"Circuit Development Pipeline"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Design"}),": Create circuit specification (AIGER, XLS)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Convert"}),": Transform to optimized TASM binary format"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Simulate"}),": Validate with plain-text simulation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Test"}),": Run small-scale FHE execution"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Scale"}),": Deploy on distributed/GPU infrastructure"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Benchmark"}),": Measure performance and optimize"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"testing-strategy",children:"Testing Strategy"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Unit Tests"}),": Individual module functionality"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Integration Tests"}),": Multi-module workflows"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Performance Tests"}),": Throughput and latency measurement"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Stress Tests"}),": Long-running stability validation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Regression Tests"}),": Continuous integration validation"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"performance-characteristics",children:"Performance Characteristics"}),"\n",(0,s.jsx)(n.h3,{id:"scalability-factors",children:"Scalability Factors"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Circuit Size"}),": Number of gates and circuit depth"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Batch Size"}),": Operations processed simultaneously"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Worker Count"}),": Parallel execution threads/processes"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Memory"}),": Available RAM for ciphertext storage"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"optimization-strategies",children:"Optimization Strategies"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Scheduling"}),": Dependency-aware parallel execution"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Batching"}),": Group operations for efficiency"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Caching"}),": Reuse computed intermediate results"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Memory Management"}),": Efficient ciphertext lifecycle"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"installation-and-setup",children:"Installation and Setup"}),"\n",(0,s.jsx)(n.h3,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Create conda environment\nconda create -n pytfhe python=3.9.13\nconda activate pytfhe\n\n# Update submodules (for backend libraries)\ngit submodule update --init --recursive\n\n# Install dependencies\npip install -r requirements.txt\n"})}),"\n",(0,s.jsx)(n.h3,{id:"backend-configuration",children:"Backend Configuration"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"pyTFHE"}),": Symbolic link to ",(0,s.jsx)(n.code,{children:"../pyTFHE-CPU"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"pyTFHE_GPU"}),": Symbolic link to ",(0,s.jsx)(n.code,{children:"../pyTFHE-CUDA"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Verification"}),": Ensure backend directories exist and are properly compiled"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"common-usage-patterns",children:"Common Usage Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"basic-circuit-execution",children:"Basic Circuit Execution"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# CPU execution with 8 workers\npython -m pyTNFS.runner.main -i circuit.lut -c 8\n\n# GPU execution with batching  \npython -m pyTNFS.runner.main_gpu circuit.lut.gz 1024 102400\n\n# Distributed Ray execution\npython -m pyTNFS.runner.main -i circuit.lut -c 16 --ray ray://head:10001\n"})}),"\n",(0,s.jsx)(n.h3,{id:"circuit-format-conversion",children:"Circuit Format Conversion"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# XLS IR to TASM\npython -m pyTNFS.xls_ir2tasm.ir2tasm circuit.bool.ir\n\n# Results in circuit.bool.ir.tasm (compressed)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"simulation-and-testing",children:"Simulation and Testing"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Run basic simulation\npython -m pyTNFS.simulate.simulate\n\n# Run performance benchmarks\npython -m pyTNFS.benchmark.ray_benchmark --num 10000 --num_threads 8\n"})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>o});var r=i(6540);const s={},t=r.createContext(s);function l(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);