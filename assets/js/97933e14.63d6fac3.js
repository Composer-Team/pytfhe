"use strict";(self.webpackChunkpy_tfhe_oss_doc=self.webpackChunkpy_tfhe_oss_doc||[]).push([[9700],{4910:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>u,frontMatter:()=>l,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"submodules/pytfhe-rs/core-modules","title":"Core Modules API Reference","description":"The core modules and their APIs in PyTFHE-rs.","source":"@site/docs/submodules/pytfhe-rs/core-modules.md","sourceDirName":"submodules/pytfhe-rs","slug":"/submodules/pytfhe-rs/core-modules","permalink":"/pytfhe/docs/submodules/pytfhe-rs/core-modules","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/submodules/pytfhe-rs/core-modules.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Python Bindings","permalink":"/pytfhe/docs/submodules/pytfhe-rs/py-bindings"},"next":{"title":"Dev Guide and Architecture","permalink":"/pytfhe/docs/submodules/pytfhe-rs/dev-guide"}}');var i=r(4848),t=r(8453);const l={sidebar_position:4},a="Core Modules API Reference",d={},o=[{value:"lib.rs - Python Module Interface",id:"librs---python-module-interface",level:2},{value:"Functions",id:"functions",level:3},{value:"<code>tnfs</code> Module",id:"tnfs-module",level:4},{value:"ir - Intermediate Representation",id:"ir---intermediate-representation",level:2},{value:"graph_ir.rs",id:"graph_irrs",level:3},{value:"Key Types",id:"key-types",level:4},{value:"<code>GraphIRNodeType</code>",id:"graphirnodetype",level:5},{value:"<code>Instance</code>",id:"instance",level:5},{value:"<code>ModuleGraph</code>",id:"modulegraph",level:5},{value:"Key Traits",id:"key-traits",level:4},{value:"<code>WithCheckReferences</code>",id:"withcheckreferences",level:5},{value:"infer_type.rs",id:"infer_typers",level:3},{value:"Functions",id:"functions-1",level:4},{value:"<code>infer_type</code>",id:"infer_type",level:5},{value:"translate.rs",id:"translaters",level:3},{value:"Functions",id:"functions-2",level:4},{value:"<code>translate_circuit</code>",id:"translate_circuit",level:5},{value:"error.rs",id:"errorrs",level:2},{value:"Error Types",id:"error-types",level:3},{value:"<code>TraversalError</code>",id:"traversalerror",level:4},{value:"<code>MapError</code>",id:"maperror",level:4},{value:"<code>SimulationError</code>",id:"simulationerror",level:4},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Creating a Circuit Graph",id:"creating-a-circuit-graph",level:3},{value:"Working with Node Types",id:"working-with-node-types",level:3},{value:"Error Handling",id:"error-handling",level:3},{value:"AIGER Backend",id:"aiger-backend",level:2},{value:"aiger_data_structure.rs",id:"aiger_data_structurers",level:3},{value:"Key Types",id:"key-types-1",level:4},{value:"<code>AigerGraph</code>",id:"aigergraph",level:5},{value:"<code>SignalSource</code>",id:"signalsource",level:5},{value:"<code>AigInstruction</code>",id:"aiginstruction",level:5},{value:"Traits",id:"traits",level:4},{value:"<code>AigerGraphGen</code>",id:"aigergraphgen",level:5},{value:"aig_map.rs",id:"aig_maprs",level:3},{value:"Key Functions",id:"key-functions",level:4},{value:"<code>aig_map</code>",id:"aig_map",level:5},{value:"Helper Functions",id:"helper-functions",level:5},{value:"LUT Backend",id:"lut-backend",level:2},{value:"lut_asm_gen.rs",id:"lut_asm_genrs",level:3},{value:"Key Types",id:"key-types-2",level:4},{value:"<code>LUTInstruction</code>",id:"lutinstruction",level:5},{value:"<code>LUTGraph</code>",id:"lutgraph",level:5},{value:"Traits",id:"traits-1",level:4},{value:"<code>WithConvertToLUTAsm</code>",id:"withconverttolutasm",level:5},{value:"Key Functions",id:"key-functions-1",level:4},{value:"<code>generate_lut_asm</code>",id:"generate_lut_asm",level:5},{value:"lut_map.rs",id:"lut_maprs",level:3},{value:"Key Functions",id:"key-functions-2",level:4},{value:"<code>lut_map</code>",id:"lut_map",level:5},{value:"<code>optimize_lut_graph</code>",id:"optimize_lut_graph",level:5},{value:"Common Backend Types",id:"common-backend-types",level:2},{value:"Compression Support",id:"compression-support",level:3},{value:"Binary Encoding",id:"binary-encoding",level:3},{value:"Usage Examples",id:"usage-examples-1",level:2},{value:"AIGER Generation",id:"aiger-generation",level:3},{value:"Working with AIGER Instructions",id:"working-with-aiger-instructions",level:3},{value:"LUT Generation",id:"lut-generation",level:3},{value:"Working with LUT Instructions",id:"working-with-lut-instructions",level:3},{value:"Compression",id:"compression",level:3},{value:"Error Handling",id:"error-handling-1",level:3},{value:"FIRRTL Frontend",id:"firrtl-frontend",level:2},{value:"ir.rs - FIRRTL IR Types",id:"irrs---firrtl-ir-types",level:3},{value:"Types",id:"types",level:4},{value:"<code>Type</code>",id:"type",level:5},{value:"<code>Direction</code>",id:"direction",level:5},{value:"<code>Expression</code>",id:"expression",level:5},{value:"<code>Statement</code>",id:"statement",level:5},{value:"<code>Port</code>",id:"port",level:5},{value:"<code>Module</code>",id:"module",level:5},{value:"<code>Circuit</code>",id:"circuit",level:5},{value:"op.rs - Primitive Operations",id:"oprs---primitive-operations",level:3},{value:"<code>PrimOp&lt;T&gt;</code>",id:"primopt",level:4},{value:"traverse.rs - AST Traversal",id:"traversers---ast-traversal",level:3},{value:"Core Functions",id:"core-functions",level:4},{value:"<code>traverse</code>",id:"traverse",level:5},{value:"<code>traverse_circuit</code>",id:"traverse_circuit",level:5},{value:"<code>traverse_module</code>",id:"traverse_module",level:5},{value:"<code>traverse_statement</code>",id:"traverse_statement",level:5},{value:"<code>traverse_expression</code>",id:"traverse_expression",level:5},{value:"<code>traverse_type</code>",id:"traverse_type",level:5},{value:"Helper Functions",id:"helper-functions-1",level:4},{value:"<code>print_node</code>",id:"print_node",level:5},{value:"<code>traverse_width</code>",id:"traverse_width",level:5},{value:"Yosys Frontend",id:"yosys-frontend",level:2},{value:"yosys_json.rs",id:"yosys_jsonrs",level:3},{value:"Key Functions",id:"key-functions-3",level:4},{value:"<code>parse_yosys_json</code>",id:"parse_yosys_json",level:5},{value:"rtlil.rs",id:"rtlilrs",level:3},{value:"Key Functions",id:"key-functions-4",level:4},{value:"<code>parse_rtlil</code>",id:"parse_rtlil",level:5},{value:"yosys_op_map.rs",id:"yosys_op_maprs",level:3},{value:"Usage Examples",id:"usage-examples-2",level:2},{value:"Parsing FIRRTL",id:"parsing-firrtl",level:3},{value:"Working with Types",id:"working-with-types",level:3},{value:"Handling Operations",id:"handling-operations",level:3}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"core-modules-api-reference",children:"Core Modules API Reference"})}),"\n",(0,i.jsx)(n.p,{children:"The core modules and their APIs in PyTFHE-rs."}),"\n",(0,i.jsx)(n.h2,{id:"librs---python-module-interface",children:"lib.rs - Python Module Interface"}),"\n",(0,i.jsx)(n.p,{children:"The main library interface for Python bindings."}),"\n",(0,i.jsx)(n.h3,{id:"functions",children:"Functions"}),"\n",(0,i.jsxs)(n.h4,{id:"tnfs-module",children:[(0,i.jsx)(n.code,{children:"tnfs"})," Module"]}),"\n",(0,i.jsx)(n.p,{children:"The PyO3 module exposing core functionality to Python."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"#[pymodule]\nfn tnfs(_py: Python<'_>, m: &PyModule) -> PyResult<()>\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Exported Functions:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"py_greedy_scheduler"})," - Standard greedy scheduling algorithm"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"py_lut_greedy_scheduler"})," - LUT-based greedy scheduling algorithm"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"ir---intermediate-representation",children:"ir - Intermediate Representation"}),"\n",(0,i.jsx)(n.p,{children:"Core data structures for representing circuits internally."}),"\n",(0,i.jsx)(n.h3,{id:"graph_irrs",children:"graph_ir.rs"}),"\n",(0,i.jsx)(n.p,{children:"Central graph-based intermediate representation for circuits."}),"\n",(0,i.jsx)(n.h4,{id:"key-types",children:"Key Types"}),"\n",(0,i.jsx)(n.h5,{id:"graphirnodetype",children:(0,i.jsx)(n.code,{children:"GraphIRNodeType"})}),"\n",(0,i.jsx)(n.p,{children:"Represents different types of nodes in the circuit graph:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub enum GraphIRNodeType {\n    Input,                    // Circuit input\n    Output,                   // Circuit output  \n    Wire,                     // Internal wire\n    Constant(BigInt),         // Constant value\n    Register,                 // Sequential element\n    Op(PrimOp<NodeIx>),      // Primitive operation\n    Scatter(Vec<NodeIx>),     // Bit scattering\n    Gather(Vec<NodeIx>),      // Bit gathering\n    Inst(Instance),           // Module instantiation\n}\n"})}),"\n",(0,i.jsx)(n.h5,{id:"instance",children:(0,i.jsx)(n.code,{children:"Instance"})}),"\n",(0,i.jsx)(n.p,{children:"Represents module instantiations:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub struct Instance {\n    pub instance_name: String,\n    pub parameters: HashMap<String, String>,\n    pub inputs: Vec<NodeIx>,\n    pub outputs: Vec<NodeIx>,\n}\n"})}),"\n",(0,i.jsx)(n.h5,{id:"modulegraph",children:(0,i.jsx)(n.code,{children:"ModuleGraph"})}),"\n",(0,i.jsx)(n.p,{children:"Main graph structure containing the circuit representation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub struct ModuleGraph {\n    pub graph: StableDiGraph<GraphIRNode, EdgeIx>,\n    pub inputs: Vec<NodeIx>,\n    pub outputs: Vec<NodeIx>,\n    pub registers: Vec<NodeIx>,\n    // ... additional fields\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"key-traits",children:"Key Traits"}),"\n",(0,i.jsx)(n.h5,{id:"withcheckreferences",children:(0,i.jsx)(n.code,{children:"WithCheckReferences"})}),"\n",(0,i.jsx)(n.p,{children:"Interface for reference validation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub trait WithCheckReferences {\n    fn reference_to_predecessors(&self) -> Vec<NodeIx>;\n    fn reference_to_successors(&self) -> Vec<NodeIx>;\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"infer_typers",children:"infer_type.rs"}),"\n",(0,i.jsx)(n.p,{children:"Type inference system for circuit signals."}),"\n",(0,i.jsx)(n.h4,{id:"functions-1",children:"Functions"}),"\n",(0,i.jsx)(n.h5,{id:"infer_type",children:(0,i.jsx)(n.code,{children:"infer_type"})}),"\n",(0,i.jsx)(n.p,{children:"Performs type inference on the circuit graph:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub fn infer_type(module: &mut ModuleGraph) -> Result<(), InferenceError>\n"})}),"\n",(0,i.jsx)(n.p,{children:"Infers bit widths and signal types throughout the circuit based on operations and connections."}),"\n",(0,i.jsx)(n.h3,{id:"translaters",children:"translate.rs"}),"\n",(0,i.jsx)(n.p,{children:"Translation between different IR representations."}),"\n",(0,i.jsx)(n.h4,{id:"functions-2",children:"Functions"}),"\n",(0,i.jsx)(n.h5,{id:"translate_circuit",children:(0,i.jsx)(n.code,{children:"translate_circuit"})}),"\n",(0,i.jsx)(n.p,{children:"Converts frontend AST to internal graph IR:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub fn translate_circuit(circuit: Circuit) -> Result<ModuleGraph, TranslationError>\n"})}),"\n",(0,i.jsx)(n.h2,{id:"errorrs",children:"error.rs"}),"\n",(0,i.jsx)(n.p,{children:"Error handling types used throughout the system."}),"\n",(0,i.jsx)(n.h3,{id:"error-types",children:"Error Types"}),"\n",(0,i.jsx)(n.h4,{id:"traversalerror",children:(0,i.jsx)(n.code,{children:"TraversalError"})}),"\n",(0,i.jsx)(n.p,{children:"Errors during AST traversal:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub enum TraversalError {\n    ParseError(String),\n    UnsupportedConstruct(String),\n    // ... other variants\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"maperror",children:(0,i.jsx)(n.code,{children:"MapError"})}),"\n",(0,i.jsx)(n.p,{children:"Errors during compilation passes:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub enum MapError {\n    NodeNotFound,\n    InvalidOperation(String),\n    // ... other variants  \n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"simulationerror",children:(0,i.jsx)(n.code,{children:"SimulationError"})}),"\n",(0,i.jsx)(n.p,{children:"Errors during circuit simulation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub enum SimulationError {\n    InvalidState,\n    UnknownSignal(String),\n    // ... other variants\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,i.jsx)(n.h3,{id:"creating-a-circuit-graph",children:"Creating a Circuit Graph"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"use pytfhe_rs::ir::graph_ir::{ModuleGraph, GraphIRNodeType};\nuse pytfhe_rs::frontends::firrtl::traverse::traverse;\n\n// Parse FIRRTL and create graph\nlet circuit = traverse(firrtl_ast)?;\nlet mut graph = translate_circuit(circuit)?;\n\n// Perform type inference\ninfer_type(&mut graph)?;\n"})}),"\n",(0,i.jsx)(n.h3,{id:"working-with-node-types",children:"Working with Node Types"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"match node.node_type {\n    GraphIRNodeType::Input => {\n        // Handle input node\n    },\n    GraphIRNodeType::Op(ref op) => {\n        // Handle operation node\n        match op {\n            PrimOp::Add(a, b) => { /* addition */ },\n            PrimOp::And(a, b) => { /* bitwise and */ },\n            // ... other operations\n        }\n    },\n    // ... other node types\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"error-handling",children:"Error Handling"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'match result {\n    Ok(graph) => { /* process graph */ },\n    Err(TraversalError::ParseError(msg)) => {\n        eprintln!("Parse error: {}", msg);\n    },\n    Err(TraversalError::UnsupportedConstruct(construct)) => {\n        eprintln!("Unsupported construct: {}", construct);\n    },\n}\n'})}),"\n",(0,i.jsx)(n.h1,{id:"backends-api-reference",children:"Backends API Reference"}),"\n",(0,i.jsx)(n.p,{children:"The backend modules generate optimized output formats from the internal IR representation."}),"\n",(0,i.jsx)(n.h2,{id:"aiger-backend",children:"AIGER Backend"}),"\n",(0,i.jsxs)(n.p,{children:["Located in ",(0,i.jsx)(n.code,{children:"src/backends/aiger/"}),", generates And-Inverter Graph (AIG) format output."]}),"\n",(0,i.jsx)(n.h3,{id:"aiger_data_structurers",children:"aiger_data_structure.rs"}),"\n",(0,i.jsx)(n.p,{children:"Core data structures for AIGER representation."}),"\n",(0,i.jsx)(n.h4,{id:"key-types-1",children:"Key Types"}),"\n",(0,i.jsx)(n.h5,{id:"aigergraph",children:(0,i.jsx)(n.code,{children:"AigerGraph"})}),"\n",(0,i.jsx)(n.p,{children:"Main AIGER graph structure:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub struct AigerGraph {\n    pub id_map: HashMap<SignalIx, AigInstruction>,\n    pub inputs: Vec<SignalIx>,\n    pub outputs: Vec<SignalIx>,\n    pub latches: Vec<SignalIx>,\n    pub max_var: SignalIx,\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Methods:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"impl AigerGraph {\n    pub fn new() -> Self;\n    pub fn from_bin(bytes: Vec<u8>) -> Self;        // Parse binary AIGER\n    pub fn to_bin(&self) -> Vec<u8>;                // Generate binary AIGER\n    pub fn add_input(&mut self) -> SignalIx;        // Add input signal\n    pub fn add_latch(&mut self, input: SignalSource) -> SignalIx;  // Add latch\n    pub fn add_and_gate(&mut self, lhs: SignalSource, rhs: SignalSource) -> SignalIx;\n    pub fn add_output(&mut self, input: SignalSource);\n}\n"})}),"\n",(0,i.jsx)(n.h5,{id:"signalsource",children:(0,i.jsx)(n.code,{children:"SignalSource"})}),"\n",(0,i.jsx)(n.p,{children:"Represents a signal with optional inversion:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"#[pyclass]\npub struct SignalSource {\n    pub idx: SignalIx,      // Signal index\n    pub invert: bool,       // Whether signal is inverted\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Methods:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"impl SignalSource {\n    pub fn to_bin(&self) -> Vec<u8>;        // Binary representation\n    pub fn to_usize(&self) -> usize;        // Convert to index\n    pub fn new(idx: SignalIx, invert: bool) -> Self;\n}\n"})}),"\n",(0,i.jsx)(n.h5,{id:"aiginstruction",children:(0,i.jsx)(n.code,{children:"AigInstruction"})}),"\n",(0,i.jsx)(n.p,{children:"Individual AIGER instructions:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub enum AigInstruction {\n    Input,                              // Primary input\n    Latch(SignalSource),               // Sequential element\n    And(SignalSource, SignalSource),   // AND gate\n    Output(SignalSource),              // Primary output\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"traits",children:"Traits"}),"\n",(0,i.jsx)(n.h5,{id:"aigergraphgen",children:(0,i.jsx)(n.code,{children:"AigerGraphGen"})}),"\n",(0,i.jsx)(n.p,{children:"Trait for generating AIGER from other representations:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub trait AigerGraphGen {\n    fn to_aiger_graph(&self) -> AigerGraph;\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"aig_maprs",children:"aig_map.rs"}),"\n",(0,i.jsx)(n.p,{children:"Mapping functions from internal IR to AIGER format."}),"\n",(0,i.jsx)(n.h4,{id:"key-functions",children:"Key Functions"}),"\n",(0,i.jsx)(n.h5,{id:"aig_map",children:(0,i.jsx)(n.code,{children:"aig_map"})}),"\n",(0,i.jsx)(n.p,{children:"Main mapping function:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub fn aig_map(module: &ModuleGraph) -> Result<AigerGraph, MapError>\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Converts a ",(0,i.jsx)(n.code,{children:"ModuleGraph"})," to ",(0,i.jsx)(n.code,{children:"AigerGraph"}),", handling:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Wire mapping and connection resolution"}),"\n",(0,i.jsx)(n.li,{children:"Operation decomposition to AND gates"}),"\n",(0,i.jsx)(n.li,{children:"Input/output port mapping"}),"\n",(0,i.jsx)(n.li,{children:"Sequential element (register) handling"}),"\n"]}),"\n",(0,i.jsx)(n.h5,{id:"helper-functions",children:"Helper Functions"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub fn map_operation(op: &PrimOp<NodeIx>, aig: &mut AigerGraph) -> Result<SignalIx, MapError>;\npub fn map_wire_connections(module: &ModuleGraph, aig: &mut AigerGraph) -> Result<(), MapError>;\n"})}),"\n",(0,i.jsx)(n.h2,{id:"lut-backend",children:"LUT Backend"}),"\n",(0,i.jsxs)(n.p,{children:["Located in ",(0,i.jsx)(n.code,{children:"src/backends/lut/"}),", generates Look-Up Table based implementations."]}),"\n",(0,i.jsx)(n.h3,{id:"lut_asm_genrs",children:"lut_asm_gen.rs"}),"\n",(0,i.jsx)(n.p,{children:"LUT assembly generation and data structures."}),"\n",(0,i.jsx)(n.h4,{id:"key-types-2",children:"Key Types"}),"\n",(0,i.jsx)(n.h5,{id:"lutinstruction",children:(0,i.jsx)(n.code,{children:"LUTInstruction"})}),"\n",(0,i.jsx)(n.p,{children:"LUT-based instruction set:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub enum LUTInstruction {\n    Header,                 // File header\n    Input,                  // Input declaration  \n    Output(usize),          // Output declaration with index\n    LUT(usize, usize, u32), // LUT with two inputs and truth table\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Methods:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"impl LUTInstruction {\n    pub fn to_bytes(&self) -> Vec<u8>;          // Binary encoding\n    pub fn from_bytes(bytes: &[u8]) -> Self;    // Binary decoding\n}\n"})}),"\n",(0,i.jsx)(n.h5,{id:"lutgraph",children:(0,i.jsx)(n.code,{children:"LUTGraph"})}),"\n",(0,i.jsx)(n.p,{children:"Graph structure for LUT-based circuits:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub struct LUTGraph {\n    pub instructions: Vec<LUTInstruction>,\n    pub num_inputs: usize,\n    pub num_outputs: usize,\n    pub num_luts: usize,\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"traits-1",children:"Traits"}),"\n",(0,i.jsx)(n.h5,{id:"withconverttolutasm",children:(0,i.jsx)(n.code,{children:"WithConvertToLUTAsm"})}),"\n",(0,i.jsx)(n.p,{children:"Conversion trait for LUT assembly:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub trait WithConvertToLUTAsm {\n    fn to_lut_asm(&self) -> Result<LUTGraph, ConversionError>;\n    fn to_lut_asm_bytes(&self) -> Result<Vec<u8>, ConversionError>;\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"key-functions-1",children:"Key Functions"}),"\n",(0,i.jsx)(n.h5,{id:"generate_lut_asm",children:(0,i.jsx)(n.code,{children:"generate_lut_asm"})}),"\n",(0,i.jsx)(n.p,{children:"Generate LUT assembly from graph IR:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub fn generate_lut_asm(module: &ModuleGraph) -> Result<LUTGraph, MapError>\n"})}),"\n",(0,i.jsx)(n.h3,{id:"lut_maprs",children:"lut_map.rs"}),"\n",(0,i.jsx)(n.p,{children:"Mapping functions for LUT-based backend."}),"\n",(0,i.jsx)(n.h4,{id:"key-functions-2",children:"Key Functions"}),"\n",(0,i.jsx)(n.h5,{id:"lut_map",children:(0,i.jsx)(n.code,{children:"lut_map"})}),"\n",(0,i.jsx)(n.p,{children:"Main LUT mapping function:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub fn lut_map(module: &ModuleGraph) -> Result<LUTGraph, MapError>\n"})}),"\n",(0,i.jsx)(n.p,{children:"Converts internal IR to LUT representation, handling:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Operation decomposition to 2-input LUTs"}),"\n",(0,i.jsx)(n.li,{children:"Truth table generation"}),"\n",(0,i.jsx)(n.li,{children:"Wire routing optimization"}),"\n",(0,i.jsx)(n.li,{children:"Input/output mapping"}),"\n"]}),"\n",(0,i.jsx)(n.h5,{id:"optimize_lut_graph",children:(0,i.jsx)(n.code,{children:"optimize_lut_graph"})}),"\n",(0,i.jsx)(n.p,{children:"LUT graph optimization:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub fn optimize_lut_graph(lut_graph: &mut LUTGraph) -> Result<(), MapError>\n"})}),"\n",(0,i.jsx)(n.h2,{id:"common-backend-types",children:"Common Backend Types"}),"\n",(0,i.jsx)(n.h3,{id:"compression-support",children:"Compression Support"}),"\n",(0,i.jsxs)(n.p,{children:["Both backends support compression through the ",(0,i.jsx)(n.code,{children:"common::compression"})," module:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub fn compress_data(data: &[u8]) -> Result<Vec<u8>, CompressionError>;\npub fn decompress_data(data: &[u8]) -> Result<Vec<u8>, CompressionError>;\n"})}),"\n",(0,i.jsx)(n.h3,{id:"binary-encoding",children:"Binary Encoding"}),"\n",(0,i.jsx)(n.p,{children:"All backends support binary encoding for efficient storage:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub trait WithConvertToBytes {\n    fn to_bytes(&self) -> Vec<u8>;\n    fn from_bytes(bytes: &[u8]) -> Self;\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"usage-examples-1",children:"Usage Examples"}),"\n",(0,i.jsx)(n.h3,{id:"aiger-generation",children:"AIGER Generation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use pytfhe_rs::backends::aiger::aig_map::aig_map;\nuse pytfhe_rs::backends::aiger::aiger_data_structure::AigerGraph;\n\n// Convert module graph to AIGER\nlet aig_graph = aig_map(&module_graph)?;\n\n// Generate binary AIGER format\nlet aiger_binary = aig_graph.to_bin();\n\n// Write to file\nstd::fs::write("output.aig", aiger_binary)?;\n'})}),"\n",(0,i.jsx)(n.h3,{id:"working-with-aiger-instructions",children:"Working with AIGER Instructions"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"use pytfhe_rs::backends::aiger::aiger_data_structure::{AigInstruction, SignalSource};\n\n// Create AIGER graph\nlet mut aig = AigerGraph::new();\n\n// Add inputs\nlet input_a = aig.add_input();\nlet input_b = aig.add_input();\n\n// Add AND gate\nlet and_result = aig.add_and_gate(\n    SignalSource::new(input_a, false),\n    SignalSource::new(input_b, false)\n);\n\n// Add output\naig.add_output(SignalSource::new(and_result, false));\n"})}),"\n",(0,i.jsx)(n.h3,{id:"lut-generation",children:"LUT Generation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use pytfhe_rs::backends::lut::lut_map::lut_map;\nuse pytfhe_rs::backends::lut::lut_asm_gen::WithConvertToLUTAsm;\n\n// Convert to LUT representation\nlet lut_graph = lut_map(&module_graph)?;\n\n// Generate LUT assembly\nlet lut_asm = module_graph.to_lut_asm()?;\nlet lut_binary = module_graph.to_lut_asm_bytes()?;\n\n// Write LUT assembly\nstd::fs::write("output.lut", lut_binary)?;\n'})}),"\n",(0,i.jsx)(n.h3,{id:"working-with-lut-instructions",children:"Working with LUT Instructions"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"use pytfhe_rs::backends::lut::lut_asm_gen::{LUTInstruction, LUTGraph};\n\n// Create LUT graph\nlet mut lut_graph = LUTGraph {\n    instructions: vec![\n        LUTInstruction::Header,\n        LUTInstruction::Input,\n        LUTInstruction::Input,\n        LUTInstruction::LUT(0, 1, 0b1000), // AND gate truth table\n        LUTInstruction::Output(2),\n    ],\n    num_inputs: 2,\n    num_outputs: 1,\n    num_luts: 1,\n};\n\n// Convert to binary\nlet binary_data: Vec<u8> = lut_graph.instructions\n    .iter()\n    .flat_map(|inst| inst.to_bytes())\n    .collect();\n"})}),"\n",(0,i.jsx)(n.h3,{id:"compression",children:"Compression"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"use pytfhe_rs::common::compression::{compress_data, decompress_data};\n\n// Compress AIGER output\nlet aiger_binary = aig_graph.to_bin();\nlet compressed = compress_data(&aiger_binary)?;\n\n// Later, decompress\nlet decompressed = decompress_data(&compressed)?;\nlet restored_aig = AigerGraph::from_bin(decompressed);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"error-handling-1",children:"Error Handling"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use pytfhe_rs::error::MapError;\n\nmatch aig_map(&module_graph) {\n    Ok(aig) => {\n        // Process AIGER graph\n        println!("Generated {} gates", aig.id_map.len());\n    },\n    Err(MapError::NodeNotFound) => {\n        eprintln!("Graph contains invalid node references");\n    },\n    Err(MapError::InvalidOperation(op)) => {\n        eprintln!("Unsupported operation: {}", op);\n    },\n    Err(e) => {\n        eprintln!("Mapping error: {:?}", e);\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h1,{id:"frontends-api-reference",children:"Frontends API Reference"}),"\n",(0,i.jsx)(n.p,{children:"The frontend modules handle parsing of various hardware description language formats into the internal IR."}),"\n",(0,i.jsx)(n.h2,{id:"firrtl-frontend",children:"FIRRTL Frontend"}),"\n",(0,i.jsxs)(n.p,{children:["Located in ",(0,i.jsx)(n.code,{children:"src/frontends/firrtl/"}),", this module provides parsing support for FIRRTL (Flexible Intermediate Representation for RTL)."]}),"\n",(0,i.jsx)(n.h3,{id:"irrs---firrtl-ir-types",children:"ir.rs - FIRRTL IR Types"}),"\n",(0,i.jsx)(n.p,{children:"Core data structures representing FIRRTL constructs."}),"\n",(0,i.jsx)(n.h4,{id:"types",children:"Types"}),"\n",(0,i.jsx)(n.h5,{id:"type",children:(0,i.jsx)(n.code,{children:"Type"})}),"\n",(0,i.jsx)(n.p,{children:"FIRRTL type system:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub enum Type {\n    Clock,              // Clock signal\n    AsyncReset,         // Asynchronous reset\n    Reset,              // Synchronous reset  \n    UInt(u64),          // Unsigned integer with width\n    SInt(u64),          // Signed integer with width\n    Const(u64),         // Constant with width\n    Unknown,            // Unknown/inferred type\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Methods:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"impl Type {\n    pub fn get_width(&self) -> u64;  // Get bit width of type\n}\n"})}),"\n",(0,i.jsx)(n.h5,{id:"direction",children:(0,i.jsx)(n.code,{children:"Direction"})}),"\n",(0,i.jsx)(n.p,{children:"Port directions:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub enum Direction {\n    Input,              // Input port\n    Output,             // Output port\n}\n"})}),"\n",(0,i.jsx)(n.h5,{id:"expression",children:(0,i.jsx)(n.code,{children:"Expression"})}),"\n",(0,i.jsx)(n.p,{children:"FIRRTL expressions:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub enum Expression {\n    Reference(ID),                    // Signal reference\n    Literal(BigInt, Type),           // Literal value\n    PrimOp(PrimOp<Expression>),      // Primitive operation\n    SubField(Box<Expression>, ID),    // Field access\n    SubIndex(Box<Expression>, u64),   // Array index\n    Mux(Box<Expression>, Box<Expression>, Box<Expression>), // Multiplexer\n    // ... additional expression types\n}\n"})}),"\n",(0,i.jsx)(n.h5,{id:"statement",children:(0,i.jsx)(n.code,{children:"Statement"})}),"\n",(0,i.jsx)(n.p,{children:"FIRRTL statements:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub enum Statement {\n    DefWire(ID, Type),               // Wire definition\n    DefReg(ID, Type, Expression),    // Register definition\n    DefNode(ID, Expression),         // Node definition\n    Connect(Expression, Expression), // Connection\n    When(Expression, Vec<Statement>), // Conditional\n    // ... additional statement types\n}\n"})}),"\n",(0,i.jsx)(n.h5,{id:"port",children:(0,i.jsx)(n.code,{children:"Port"})}),"\n",(0,i.jsx)(n.p,{children:"Module port definition:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub struct Port {\n    pub name: ID,\n    pub direction: Direction,\n    pub port_type: Type,\n}\n"})}),"\n",(0,i.jsx)(n.h5,{id:"module",children:(0,i.jsx)(n.code,{children:"Module"})}),"\n",(0,i.jsx)(n.p,{children:"FIRRTL module:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub struct Module {\n    pub name: ID,\n    pub ports: Vec<Port>,\n    pub statements: Vec<Statement>,\n}\n"})}),"\n",(0,i.jsx)(n.h5,{id:"circuit",children:(0,i.jsx)(n.code,{children:"Circuit"})}),"\n",(0,i.jsx)(n.p,{children:"Top-level FIRRTL circuit:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub struct Circuit {\n    pub modules: Vec<Module>,\n    pub main: ID,  // Name of main module\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"oprs---primitive-operations",children:"op.rs - Primitive Operations"}),"\n",(0,i.jsx)(n.p,{children:"FIRRTL primitive operations."}),"\n",(0,i.jsx)(n.h4,{id:"primopt",children:(0,i.jsx)(n.code,{children:"PrimOp<T>"})}),"\n",(0,i.jsx)(n.p,{children:"Generic primitive operation type:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub enum PrimOp<T> {\n    // Arithmetic\n    Add(T, T),\n    Sub(T, T), \n    Mul(T, T),\n    Div(T, T),\n    Rem(T, T),\n    \n    // Bitwise\n    And(T, T),\n    Or(T, T),\n    Xor(T, T),\n    Not(T),\n    \n    // Comparison\n    Lt(T, T),\n    Leq(T, T),\n    Gt(T, T),\n    Geq(T, T),\n    Eq(T, T),\n    Neq(T, T),\n    \n    // Bit manipulation\n    Shl(T, T),      // Shift left\n    Shr(T, T),      // Shift right\n    Dshl(T, T),     // Dynamic shift left\n    Dshr(T, T),     // Dynamic shift right\n    \n    // Type conversion\n    AsUInt(T),      // Convert to unsigned\n    AsSInt(T),      // Convert to signed\n    AsClock(T),     // Convert to clock\n    \n    // Bit extraction\n    Bits(T, u64, u64), // Extract bits [high:low]\n    Head(T, u64),      // Take high bits\n    Tail(T, u64),      // Take low bits\n    Pad(T, u64),       // Pad to width\n    \n    // Concatenation\n    Cat(T, T),      // Concatenate bits\n    \n    // Reduction\n    AndR(T),        // Reduce with AND\n    OrR(T),         // Reduce with OR\n    XorR(T),        // Reduce with XOR\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"traversers---ast-traversal",children:"traverse.rs - AST Traversal"}),"\n",(0,i.jsx)(n.p,{children:"Functions for parsing FIRRTL using tree-sitter and converting to internal IR."}),"\n",(0,i.jsx)(n.h4,{id:"core-functions",children:"Core Functions"}),"\n",(0,i.jsx)(n.h5,{id:"traverse",children:(0,i.jsx)(n.code,{children:"traverse"})}),"\n",(0,i.jsx)(n.p,{children:"Main entry point for FIRRTL parsing:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub fn traverse(tree: Tree, source_code: &[u8]) -> Result<Circuit, TraversalError>\n"})}),"\n",(0,i.jsx)(n.p,{children:"Parses a tree-sitter AST into FIRRTL IR."}),"\n",(0,i.jsx)(n.h5,{id:"traverse_circuit",children:(0,i.jsx)(n.code,{children:"traverse_circuit"})}),"\n",(0,i.jsx)(n.p,{children:"Parse circuit node:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub fn traverse_circuit(node: Node, source_code: &[u8]) -> Result<Circuit, TraversalError>\n"})}),"\n",(0,i.jsx)(n.h5,{id:"traverse_module",children:(0,i.jsx)(n.code,{children:"traverse_module"})}),"\n",(0,i.jsx)(n.p,{children:"Parse module node:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub fn traverse_module(node: Node, source_code: &[u8]) -> Result<Module, TraversalError>\n"})}),"\n",(0,i.jsx)(n.h5,{id:"traverse_statement",children:(0,i.jsx)(n.code,{children:"traverse_statement"})}),"\n",(0,i.jsx)(n.p,{children:"Parse statement node:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub fn traverse_statement(node: Node, source_code: &[u8]) -> Result<Statement, TraversalError>\n"})}),"\n",(0,i.jsx)(n.h5,{id:"traverse_expression",children:(0,i.jsx)(n.code,{children:"traverse_expression"})}),"\n",(0,i.jsx)(n.p,{children:"Parse expression node:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub fn traverse_expression(node: Node, source_code: &[u8]) -> Result<Expression, TraversalError>\n"})}),"\n",(0,i.jsx)(n.h5,{id:"traverse_type",children:(0,i.jsx)(n.code,{children:"traverse_type"})}),"\n",(0,i.jsx)(n.p,{children:"Parse type node:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub fn traverse_type(node: Node, source_code: &[u8]) -> Result<Type, TraversalError>\n"})}),"\n",(0,i.jsx)(n.h4,{id:"helper-functions-1",children:"Helper Functions"}),"\n",(0,i.jsx)(n.h5,{id:"print_node",children:(0,i.jsx)(n.code,{children:"print_node"})}),"\n",(0,i.jsx)(n.p,{children:"Debug helper for printing AST nodes:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub fn print_node(base_name: &str, node: Node, source: &[u8])\n"})}),"\n",(0,i.jsx)(n.h5,{id:"traverse_width",children:(0,i.jsx)(n.code,{children:"traverse_width"})}),"\n",(0,i.jsx)(n.p,{children:"Parse bit width from AST:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub fn traverse_width(node: Node, source_code: &[u8]) -> Result<u64, TraversalError>\n"})}),"\n",(0,i.jsx)(n.h2,{id:"yosys-frontend",children:"Yosys Frontend"}),"\n",(0,i.jsxs)(n.p,{children:["Located in ",(0,i.jsx)(n.code,{children:"src/frontends/yosys/"}),", supports Yosys JSON and RTLIL formats."]}),"\n",(0,i.jsx)(n.h3,{id:"yosys_jsonrs",children:"yosys_json.rs"}),"\n",(0,i.jsx)(n.p,{children:"Parser for Yosys JSON netlists."}),"\n",(0,i.jsx)(n.h4,{id:"key-functions-3",children:"Key Functions"}),"\n",(0,i.jsx)(n.h5,{id:"parse_yosys_json",children:(0,i.jsx)(n.code,{children:"parse_yosys_json"})}),"\n",(0,i.jsx)(n.p,{children:"Parse Yosys JSON format:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub fn parse_yosys_json(json_str: &str) -> Result<ModuleGraph, ParseError>\n"})}),"\n",(0,i.jsx)(n.h3,{id:"rtlilrs",children:"rtlil.rs"}),"\n",(0,i.jsx)(n.p,{children:"Parser for RTLIL (Register Transfer Level Intermediate Language)."}),"\n",(0,i.jsx)(n.h4,{id:"key-functions-4",children:"Key Functions"}),"\n",(0,i.jsx)(n.h5,{id:"parse_rtlil",children:(0,i.jsx)(n.code,{children:"parse_rtlil"})}),"\n",(0,i.jsx)(n.p,{children:"Parse RTLIL format:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub fn parse_rtlil(rtlil_str: &str) -> Result<ModuleGraph, ParseError>\n"})}),"\n",(0,i.jsx)(n.h3,{id:"yosys_op_maprs",children:"yosys_op_map.rs"}),"\n",(0,i.jsx)(n.p,{children:"Operation mapping for Yosys primitives to internal IR."}),"\n",(0,i.jsx)(n.h2,{id:"usage-examples-2",children:"Usage Examples"}),"\n",(0,i.jsx)(n.h3,{id:"parsing-firrtl",children:"Parsing FIRRTL"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use pytfhe_rs::frontends::firrtl::traverse::traverse;\nuse tree_sitter::{Language, Parser};\n\nextern "C" { fn tree_sitter_firrtl() -> Language; }\n\nlet mut parser = Parser::new();\nparser.set_language(unsafe { tree_sitter_firrtl() })?;\n\nlet source_code = std::fs::read("circuit.fir")?;\nlet tree = parser.parse(&source_code, None).unwrap();\n\nlet circuit = traverse(tree, &source_code)?;\nprintln!("Parsed {} modules", circuit.modules.len());\n'})}),"\n",(0,i.jsx)(n.h3,{id:"working-with-types",children:"Working with Types"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use pytfhe_rs::frontends::firrtl::ir::Type;\n\nlet wire_type = Type::UInt(32);\nprintln!("Width: {}", wire_type.get_width()); // Prints: Width: 32\n\nmatch wire_type {\n    Type::UInt(w) => println!("Unsigned {}-bit", w),\n    Type::SInt(w) => println!("Signed {}-bit", w),\n    Type::Clock => println!("Clock signal"),\n    _ => println!("Other type"),\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"handling-operations",children:"Handling Operations"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use pytfhe_rs::frontends::firrtl::op::PrimOp;\n\nmatch operation {\n    PrimOp::Add(a, b) => {\n        // Handle addition\n        println!("Adding {} + {}", a, b);\n    },\n    PrimOp::Bits(signal, high, low) => {\n        // Handle bit extraction\n        println!("Extract bits [{}:{}] from {}", high, low, signal);\n    },\n    // ... handle other operations\n}\n'})})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>a});var s=r(6540);const i={},t=s.createContext(i);function l(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);