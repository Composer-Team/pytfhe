"use strict";(self.webpackChunkpy_tfhe_oss_doc=self.webpackChunkpy_tfhe_oss_doc||[]).push([[1764],{8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var t=i(6540);const r={},s=t.createContext(r);function o(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(s.Provider,{value:n},e.children)}},8778:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"submodules/aiger-tools","title":"AIGER Tools","description":"Overview","source":"@site/docs/submodules/aiger-tools.md","sourceDirName":"submodules","slug":"/submodules/aiger-tools","permalink":"/pytfhe/docs/submodules/aiger-tools","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/submodules/aiger-tools.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"PyTFHE-CPU","permalink":"/pytfhe/docs/submodules/pytfhe-cpu"},"next":{"title":"PyTFHE-CUDA","permalink":"/pytfhe/docs/submodules/pytfhe-cuda"}}');var r=i(4848),s=i(8453);const o={sidebar_position:2},a="AIGER Tools",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Key Components",id:"key-components",level:2},{value:"Circuit Parsing (<code>parse_aiger.py</code>)",id:"circuit-parsing-parse_aigerpy",level:3},{value:"Circuit Simulation (<code>simulate.py</code>)",id:"circuit-simulation-simulatepy",level:3},{value:"Plaintext Simulation",id:"plaintext-simulation",level:4},{value:"Homomorphic Encrypted Simulation",id:"homomorphic-encrypted-simulation",level:4},{value:"Practical Use Cases",id:"practical-use-cases",level:2},{value:"1. Arithmetic Circuits",id:"1-arithmetic-circuits",level:3},{value:"2. Performance Benchmarking (<code>benchmark.py</code>)",id:"2-performance-benchmarking-benchmarkpy",level:3},{value:"3. Distributed Computing (<code>and_test.py</code>)",id:"3-distributed-computing-and_testpy",level:3},{value:"4. Circuit Fuzzing and Verification (<code>fuzzing.py</code>)",id:"4-circuit-fuzzing-and-verification-fuzzingpy",level:3},{value:"5. Random Circuit Generation (<code>random_aig_gen.py</code>)",id:"5-random-circuit-generation-random_aig_genpy",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"aiger-tools",children:"AIGER Tools"})}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"aiger_tools/"})," directory under ",(0,r.jsx)(n.code,{children:"pyTFHE-CPU"})," provides comprehensive utilities for working with Boolean circuits in the AIGER (And-Inverter Graph) format using PyTFHE.\nAIGER is a standard format for representing Boolean circuits as directed acyclic graphs."]}),"\n",(0,r.jsx)(n.h2,{id:"key-components",children:"Key Components"}),"\n",(0,r.jsxs)(n.h3,{id:"circuit-parsing-parse_aigerpy",children:["Circuit Parsing (",(0,r.jsx)(n.code,{children:"parse_aiger.py"}),")"]}),"\n",(0,r.jsx)(n.p,{children:"Converts AIGER format files into NetworkX directed graphs for processing."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from aiger_tools.parse_aiger import parse_aiger_to_nxg\n\n# Parse an AIGER file into a graph structure\ngraph, inputs_map, outputs_map = parse_aiger_to_nxg("circuit.aig")\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Features:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Parses standard AIGER format files"}),"\n",(0,r.jsx)(n.li,{children:"Maps symbolic input/output names to node IDs"}),"\n",(0,r.jsx)(n.li,{children:"Converts circuits into NetworkX DiGraph objects"}),"\n",(0,r.jsx)(n.li,{children:"Handles inversion flags for gate inputs"}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"circuit-simulation-simulatepy",children:["Circuit Simulation (",(0,r.jsx)(n.code,{children:"simulate.py"}),")"]}),"\n",(0,r.jsx)(n.p,{children:"Provides both plaintext and homomorphic encrypted simulation of Boolean circuits."}),"\n",(0,r.jsx)(n.h4,{id:"plaintext-simulation",children:"Plaintext Simulation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from aiger_tools.simulate import pt_simulate\n\n# Simulate circuit in plaintext\ninputs = {input_node1: 1, input_node2: 0}  # Input values\noutputs = [output_node1, output_node2]     # Output nodes to evaluate\nresult = pt_simulate(circuit_graph, inputs, outputs)\n"})}),"\n",(0,r.jsx)(n.h4,{id:"homomorphic-encrypted-simulation",children:"Homomorphic Encrypted Simulation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from aiger_tools.simulate import tfhe_simulate\n\n# Simulate circuit homomorphically (fully encrypted)\ninputs = {input_node1: 1, input_node2: 0}\noutputs = [output_node1, output_node2]\nencrypted_result = tfhe_simulate(circuit_graph, inputs, outputs, verbose=True)\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Key Functions:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"encrypt_input()"}),": Encrypts plaintext inputs for homomorphic computation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"tfhe_encrypted_simulate()"}),": Core homomorphic circuit evaluation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"decrypt_output()"}),": Decrypts homomorphic results back to plaintext"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"poke_input()"}),": Helper for converting integers to binary input vectors"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"practical-use-cases",children:"Practical Use Cases"}),"\n",(0,r.jsx)(n.h3,{id:"1-arithmetic-circuits",children:"1. Arithmetic Circuits"}),"\n",(0,r.jsx)(n.p,{children:"Example from the codebase shows 8-bit addition:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'# Parse an 8-bit adder circuit\ngraph, inputs_map, outputs_map = parse_aiger_to_nxg("add.aig")\n\n# Create inputs for 4 + 4\ninputs_dict = poke_input(4, 4, list(inputs_map.values()))\n\n# Run homomorphic addition\ntfhe_result = tfhe_simulate(graph, inputs_dict, list(outputs_map.values()))\nplaintext_result = pt_simulate(graph, inputs_dict, list(outputs_map.values()))\n\n# Results should match\nassert tfhe_result == plaintext_result\n'})}),"\n",(0,r.jsxs)(n.h3,{id:"2-performance-benchmarking-benchmarkpy",children:["2. Performance Benchmarking (",(0,r.jsx)(n.code,{children:"benchmark.py"}),")"]}),"\n",(0,r.jsx)(n.p,{children:"Measure performance of different TFHE operations:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from aiger_tools.benchmark import benchmark_and_gate, benchmark_not_gate\n\n# Setup TFHE parameters\nparams = pyTFHE.new_default_gate_bootstrapping_parameters(110)\nsk = pyTFHE.new_random_gate_bootstrapping_secret_keyset(params)\nbk = sk.cloud\n\n# Benchmark different operations\nbenchmark_and_gate(100, bk)    # ~100ms per AND gate\nbenchmark_not_gate(100, bk)    # ~50ms per NOT gate\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Benchmark Results:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Constant generation"}),": ~microseconds"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"NOT gate"}),": ~50ms per operation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"AND gate"}),": ~100ms per operation"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"3-distributed-computing-and_testpy",children:["3. Distributed Computing (",(0,r.jsx)(n.code,{children:"and_test.py"}),")"]}),"\n",(0,r.jsx)(n.p,{children:"Scale TFHE computations across multiple workers using Ray:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import ray\nfrom aiger_tools.and_test import test_and_tfhe\n\n# Distributed AND-tree computation\n@ray.remote\ndef test_and_tfhe(depth=10):\n    # Creates an AND tree with given depth\n    # Returns 0 if any input is 0, 1 if all inputs are 1\n\nray.init()\n# Run 100 parallel AND computations with depth 1000\nresults = ray.get([test_and_tfhe.remote(depth=1000) for _ in range(100)])\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"4-circuit-fuzzing-and-verification-fuzzingpy",children:["4. Circuit Fuzzing and Verification (",(0,r.jsx)(n.code,{children:"fuzzing.py"}),")"]}),"\n",(0,r.jsx)(n.p,{children:"Automated testing to verify TFHE computation correctness:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from aiger_tools.fuzzing import fuzzing_one\nfrom aiger_tools.random_aig_gen import random_aig_gen\n\n# Generate random circuit\ncircuit, inputs, outputs = random_aig_gen(nodes=100, edges=200)\n\n# Random input testing\ninput_dict = {inp: random.randint(0, 1) for inp in inputs}\n\n# Verify TFHE matches plaintext\n_, pt_result, tfhe_result = fuzzing_one(circuit, input_dict, outputs)\nassert pt_result == tfhe_result, "TFHE computation error!"\n'})}),"\n",(0,r.jsxs)(n.h3,{id:"5-random-circuit-generation-random_aig_genpy",children:["5. Random Circuit Generation (",(0,r.jsx)(n.code,{children:"random_aig_gen.py"}),")"]}),"\n",(0,r.jsx)(n.p,{children:"Generate synthetic circuits for testing and benchmarking:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from aiger_tools.random_aig_gen import random_aig_gen\n\n# Generate random DAG-based circuit\ngraph, inputs, outputs = random_aig_gen(\n    n=1000,     # Number of nodes\n    m=2000,     # Number of edges  \n    verbose=True\n)\n\n# Circuit characteristics\nnum_gates = len(graph.nodes) - len(inputs)\ncircuit_depth = nx.dag_longest_path_length(graph)\n"})})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);