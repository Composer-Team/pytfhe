"use strict";(self.webpackChunkpy_tfhe_oss_doc=self.webpackChunkpy_tfhe_oss_doc||[]).push([[4647],{8453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>o});var i=s(6540);const r={},t=i.createContext(r);function l(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),i.createElement(t.Provider,{value:n},e.children)}},8739:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"submodules/pytfhe-frontend/xls-bridge","title":"XLS IR to TASM Converter","description":"The xls_ir2tasm module provides conversion utilities from XLS (Accelerated HLS) Intermediate Representation (IR) to TASM (TFHE Assembly) format. XLS is Google\'s hardware synthesis tool that generates optimized hardware descriptions, and this module bridges XLS output to the PyTFHE execution format.","source":"@site/docs/submodules/pytfhe-frontend/xls-bridge.md","sourceDirName":"submodules/pytfhe-frontend","slug":"/submodules/pytfhe-frontend/xls-bridge","permalink":"/pytfhe/docs/submodules/pytfhe-frontend/xls-bridge","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/submodules/pytfhe-frontend/xls-bridge.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"PyTFHE-Frontend Overview","permalink":"/pytfhe/docs/submodules/pytfhe-frontend/overview"},"next":{"title":"TFHE Assembly (TASM) Tools","permalink":"/pytfhe/docs/submodules/pytfhe-frontend/asm-tools"}}');var r=s(4848),t=s(8453);const l={sidebar_position:2},o="XLS IR to TASM Converter",a={},c=[{value:"Core Components",id:"core-components",level:2},{value:"IR to TASM Converter (<code>ir2tasm.py</code>)",id:"ir-to-tasm-converter-ir2tasmpy",level:3},{value:"Key Classes and Functions",id:"key-classes-and-functions",level:2},{value:"Parser Class",id:"parser-class",level:3},{value:"Parsing Functions",id:"parsing-functions",level:3},{value:"File Processing",id:"file-processing",level:4},{value:"Pattern Matching",id:"pattern-matching",level:4},{value:"Multi-Pass Parsing Strategy",id:"multi-pass-parsing-strategy",level:4},{value:"Binary Assembly",id:"binary-assembly",level:3},{value:"Row Assembly",id:"row-assembly",level:4},{value:"Chunk Assembly",id:"chunk-assembly",level:4},{value:"TASM Binary Generation",id:"tasm-binary-generation",level:4},{value:"File Format Support",id:"file-format-support",level:2},{value:"Input Format (XLS IR)",id:"input-format-xls-ir",level:3},{value:"Output Format (TASM Binary)",id:"output-format-tasm-binary",level:3},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Command Line Usage",id:"command-line-usage",level:3},{value:"Programmatic Usage",id:"programmatic-usage",level:3},{value:"Integration with Execution Pipeline",id:"integration-with-execution-pipeline",level:3},{value:"Conversion Pipeline",id:"conversion-pipeline",level:2},{value:"XLS to IR Generation",id:"xls-to-ir-generation",level:3},{value:"IR to TASM Conversion",id:"ir-to-tasm-conversion",level:3},{value:"TASM to FHE Execution",id:"tasm-to-fhe-execution",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"xls-ir-to-tasm-converter",children:"XLS IR to TASM Converter"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"xls_ir2tasm"})," module provides conversion utilities from XLS (Accelerated HLS) Intermediate Representation (IR) to TASM (TFHE Assembly) format. XLS is Google's hardware synthesis tool that generates optimized hardware descriptions, and this module bridges XLS output to the PyTFHE execution format."]}),"\n",(0,r.jsx)(n.h2,{id:"core-components",children:"Core Components"}),"\n",(0,r.jsxs)(n.h3,{id:"ir-to-tasm-converter-ir2tasmpy",children:["IR to TASM Converter (",(0,r.jsx)(n.code,{children:"ir2tasm.py"}),")"]}),"\n",(0,r.jsx)(n.p,{children:"Comprehensive parser and converter that transforms XLS boolean IR files into TASM binary format."}),"\n",(0,r.jsx)(n.h2,{id:"key-classes-and-functions",children:"Key Classes and Functions"}),"\n",(0,r.jsx)(n.h3,{id:"parser-class",children:"Parser Class"}),"\n",(0,r.jsx)(n.p,{children:"Main parsing engine that processes XLS IR and generates TASM binary output."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Class Attributes:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"LUT_TYPE_TABLE"})," - Mapping of gate types to LUT encodings"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"not_table: Dict"})," - Tracks NOT gate relationships"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"lut_entries: List"})," - LUT operations to be encoded"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"literals: List"})," - Constant values in the circuit"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"bit_slices: Set"})," - Primary input signals"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"id_to_line: Dict"})," - Maps IR node IDs to binary line numbers"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"LUT Type Encoding:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"LUT_TYPE_TABLE = {\n    'and': {\n        (False, False): 1,  # Regular AND\n        (False, True): 2,   # AND with second input inverted  \n        (True, False): 4,   # AND with first input inverted\n        (True, True): 7     # AND with both inputs inverted (NAND)\n    },\n    'or': {\n        (False, False): 7,  # Regular OR\n        (False, True): 13,  # OR with second input inverted\n        (True, False): 11,  # OR with first input inverted  \n        (True, True): 1     # OR with both inputs inverted (NOR)\n    },\n    'xor': {\n        (False, False): 6,  # Regular XOR\n        (True, True): 6     # XOR with both inputs inverted (same result)\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"parsing-functions",children:"Parsing Functions"}),"\n",(0,r.jsx)(n.h4,{id:"file-processing",children:"File Processing"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"extract_top_fn(filename: str) -> tuple"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Extracts the main function from XLS IR file"}),"\n",(0,r.jsxs)(n.li,{children:["Looks for function boundaries (",(0,r.jsx)(n.code,{children:"fn"})," to ",(0,r.jsx)(n.code,{children:"ret"})," statements)"]}),"\n",(0,r.jsx)(n.li,{children:"Returns lines containing the function body"}),"\n",(0,r.jsxs)(n.li,{children:["Validates ",(0,r.jsx)(n.code,{children:".bool.ir"})," file extension"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"pattern-matching",children:"Pattern Matching"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"match(re_str: str, text: str) -> str"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Utility function for regex pattern extraction"}),"\n",(0,r.jsx)(n.li,{children:"Safely handles failed matches with empty string return"}),"\n",(0,r.jsx)(n.li,{children:"Used throughout parsing for ID and value extraction"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"multi-pass-parsing-strategy",children:"Multi-Pass Parsing Strategy"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Pass 0: Literal Parsing"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"_parse_literal(line: str)"})}),"\n",(0,r.jsx)(n.li,{children:"Extracts constant values from literal statements"}),"\n",(0,r.jsxs)(n.li,{children:["Format: ",(0,r.jsx)(n.code,{children:"literal.5791: bits[1] = literal(value=0, id=5791)"})]}),"\n",(0,r.jsx)(n.li,{children:"Stores literal ID and constant value"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Pass 1: NOT Gate Parsing"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"_parse_not(line: str)"})}),"\n",(0,r.jsx)(n.li,{children:"Builds mapping of NOT operations to their inputs"}),"\n",(0,r.jsxs)(n.li,{children:["Format: ",(0,r.jsx)(n.code,{children:"not.8044: bits[1] = not(literal.5791, id=8044)"})]}),"\n",(0,r.jsx)(n.li,{children:"Creates inversion lookup table for later passes"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Pass 2: Logic Gate Parsing"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"_parse_gate(line: str)"})}),"\n",(0,r.jsx)(n.li,{children:"Processes AND, OR, XOR gates with optional input inversions"}),"\n",(0,r.jsxs)(n.li,{children:["Format: ",(0,r.jsx)(n.code,{children:"and.8046: bits[1] = and(literal.5791, literal.5792, id=8046)"})]}),"\n",(0,r.jsx)(n.li,{children:"Resolves NOT gate references to determine LUT type"}),"\n",(0,r.jsx)(n.li,{children:"Generates LUT entries with proper inversion flags"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"binary-assembly",children:"Binary Assembly"}),"\n",(0,r.jsx)(n.h4,{id:"row-assembly",children:"Row Assembly"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"_assemble_row(lhs_idx: int, rhs_idx: int, lut: int) -> tuple"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Packs node indices and LUT values into 64-bit integers"}),"\n",(0,r.jsx)(n.li,{children:"LUT bits are encoded in lower 2 bits of each operand"}),"\n",(0,r.jsx)(n.li,{children:"Node indices are shifted left by 2 bits"}),"\n",(0,r.jsx)(n.li,{children:"Returns (lhs_packed, rhs_packed) tuple"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"chunk-assembly",children:"Chunk Assembly"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"_assemble_chunk(lhs_idx: int, rhs_idx: int, lut: int) -> bytes"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Converts packed integers to 16-byte binary chunks"}),"\n",(0,r.jsx)(n.li,{children:"Uses big-endian byte order for consistency"}),"\n",(0,r.jsx)(n.li,{children:"Each chunk represents one LUT operation"}),"\n",(0,r.jsx)(n.li,{children:"Returns 16 bytes (8 bytes per operand)"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"tasm-binary-generation",children:"TASM Binary Generation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"to_tasm_bytes() -> bytes"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Generates complete TASM binary format"}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Header"}),": 16 bytes of zeros"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Literals"}),": 16 bytes of 0xFF for each literal"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Inputs"}),": 16 bytes of 0xFF for each input signal"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"LUT Operations"}),": 16-byte chunks for each gate"]}),"\n",(0,r.jsx)(n.li,{children:"Maintains ID-to-line mapping for cross-references"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"file-format-support",children:"File Format Support"}),"\n",(0,r.jsx)(n.h3,{id:"input-format-xls-ir",children:"Input Format (XLS IR)"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Extension"}),": ",(0,r.jsx)(n.code,{children:".bool.ir"})," (boolean-optimized intermediate representation)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Structure"}),": Text-based IR with function definitions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Gates"}),": Supports AND, OR, XOR, NOT operations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Literals"}),": Constant values (0 or 1)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Bit Slices"}),": Primary input signals"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"output-format-tasm-binary",children:"Output Format (TASM Binary)"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Extension"}),": ",(0,r.jsx)(n.code,{children:".tasm"})," (with optional gzip compression)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Structure"}),": Binary format compatible with PyTFHE execution engines"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Compression"}),": Automatic gzip compression for storage efficiency"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Compatibility"}),": Direct input to ",(0,r.jsx)(n.code,{children:"runner"})," module executors"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,r.jsx)(n.h3,{id:"command-line-usage",children:"Command Line Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Convert specific IR file\npython -m pyTNFS.xls_ir2tasm.ir2tasm circuit.bool.ir\n\n# Default behavior (looks for ./IRs/flatten.opt.bool.ir)  \npython -m pyTNFS.xls_ir2tasm.ir2tasm\n"})}),"\n",(0,r.jsx)(n.h3,{id:"programmatic-usage",children:"Programmatic Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from pyTNFS.xls_ir2tasm.ir2tasm import extract_top_fn, Parser\n\n# Load and parse XLS IR file\nlines = extract_top_fn("multiplier.bool.ir")\nparser = Parser(lines)\n\n# Multi-pass parsing\nparser.parse()\n\n# Generate TASM binary\ntasm_binary = parser.to_tasm_bytes()\n\n# Save with compression\nimport gzip\ncompressed = gzip.compress(tasm_binary)\nwith open("multiplier.tasm", "wb") as f:\n    f.write(compressed)\n\nprint(f"Generated {len(parser.lut_entries)} LUT operations")\nprint(f"Circuit has {len(parser.bit_slices)} inputs")\n'})}),"\n",(0,r.jsx)(n.h3,{id:"integration-with-execution-pipeline",children:"Integration with Execution Pipeline"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'# Complete workflow: XLS IR \u2192 TASM \u2192 FHE Execution\nfrom pyTNFS.xls_ir2tasm.ir2tasm import *\nfrom pyTNFS.runner.main_gpu import gpu_execute\n\n# Convert IR to TASM\nlines = extract_top_fn("circuit.bool.ir") \nparser = Parser(lines)\nparser.parse()\ntasm_binary = parser.to_tasm_bytes()\n\n# Save compressed TASM\nwith open("circuit.tasm.gz", "wb") as f:\n    f.write(gzip.compress(tasm_binary))\n\n# Execute on GPU\ngpu_execute("circuit.tasm.gz", batchsize=1024, megabatch_size=102400)\n'})}),"\n",(0,r.jsx)(n.h2,{id:"conversion-pipeline",children:"Conversion Pipeline"}),"\n",(0,r.jsx)(n.h3,{id:"xls-to-ir-generation",children:"XLS to IR Generation"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"XLS Input"}),": High-level hardware description"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Boolean Optimization"}),": XLS generates ",(0,r.jsx)(n.code,{children:".bool.ir"})," with gate-level operations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Function Extraction"}),": IR contains optimized boolean function"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"ir-to-tasm-conversion",children:"IR to TASM Conversion"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Parsing"}),": Multi-pass extraction of literals, NOTs, and gates"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"LUT Mapping"}),": Convert gate operations to LUT table lookups"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Binary Encoding"}),": Pack operations into TASM binary format"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Compression"}),": Apply gzip for storage efficiency"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"tasm-to-fhe-execution",children:"TASM to FHE Execution"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Loading"}),": TASM binary loaded by execution engines"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Scheduling"}),": Operations scheduled for parallel execution"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"FHE Execution"}),": Gates executed as homomorphic operations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Result Collection"}),": Encrypted outputs collected and decrypted"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);