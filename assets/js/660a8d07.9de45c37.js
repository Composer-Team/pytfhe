"use strict";(self.webpackChunkpy_tfhe_oss_doc=self.webpackChunkpy_tfhe_oss_doc||[]).push([[2069],{7837:(n,e,s)=>{s.r(e),s.d(e,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"submodules/pytfhe-frontend/asm-tools","title":"TFHE Assembly (TASM) Tools","description":"The asm_tools module provides utilities for loading and parsing binary assembly formats used in the PyTFHE system. It handles two main binary formats: TNFS (Threshold Network File System) binary format and LUT (Look-Up Table) binary format. These formats represent compiled circuits in a form optimized for FHE execution.","source":"@site/docs/submodules/pytfhe-frontend/asm-tools.md","sourceDirName":"submodules/pytfhe-frontend","slug":"/submodules/pytfhe-frontend/asm-tools","permalink":"/pytfhe/docs/submodules/pytfhe-frontend/asm-tools","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/submodules/pytfhe-frontend/asm-tools.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"XLS IR to TASM Converter","permalink":"/pytfhe/docs/submodules/pytfhe-frontend/xls-bridge"},"next":{"title":"Boolean TFHE Program Runner","permalink":"/pytfhe/docs/submodules/pytfhe-frontend/runner"}}');var t=s(4848),r=s(8453);const l={sidebar_position:3},o="TFHE Assembly (TASM) Tools",a={},d=[{value:"Core Components",id:"core-components",level:2},{value:"TNFS Binary Format (<code>load_tnfs_bin.py</code>)",id:"tnfs-binary-format-load_tnfs_binpy",level:3},{value:"LUT Binary Format (<code>load_lut_bin.py</code>)",id:"lut-binary-format-load_lut_binpy",level:3},{value:"Data Flow",id:"data-flow",level:2},{value:"TNFS Binary Processing",id:"tnfs-binary-processing",level:3},{value:"LUT Binary Processing",id:"lut-binary-processing",level:3},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Loading TNFS Binary",id:"loading-tnfs-binary",level:3},{value:"Inspecting TNFS Binary",id:"inspecting-tnfs-binary",level:3},{value:"Analyzing LUT Binary",id:"analyzing-lut-binary",level:3},{value:"Binary Format Details",id:"binary-format-details",level:2},{value:"Signal Encoding",id:"signal-encoding",level:3},{value:"Node Types",id:"node-types",level:3},{value:"Compression Support",id:"compression-support",level:3}];function c(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"tfhe-assembly-tasm-tools",children:"TFHE Assembly (TASM) Tools"})}),"\n",(0,t.jsxs)(e.p,{children:["The ",(0,t.jsx)(e.code,{children:"asm_tools"})," module provides utilities for loading and parsing binary assembly formats used in the PyTFHE system. It handles two main binary formats: TNFS (Threshold Network File System) binary format and LUT (Look-Up Table) binary format. These formats represent compiled circuits in a form optimized for FHE execution."]}),"\n",(0,t.jsx)(e.h2,{id:"core-components",children:"Core Components"}),"\n",(0,t.jsxs)(e.h3,{id:"tnfs-binary-format-load_tnfs_binpy",children:["TNFS Binary Format (",(0,t.jsx)(e.code,{children:"load_tnfs_bin.py"}),")"]}),"\n",(0,t.jsx)(e.p,{children:"Utilities for loading and parsing TNFS binary format files, which represent circuits in a binary format optimized for threshold network execution."}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Key Functions:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.code,{children:"load_tnfs_bin(raw_bin: bytes, compression: bool = False) -> (AigerGraph, tuple)"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Loads TNFS binary format and converts to AigerGraph"}),"\n",(0,t.jsx)(e.li,{children:"Returns AigerGraph and statistics tuple (M, I, L, O, A)"}),"\n",(0,t.jsx)(e.li,{children:"Supports optional gzip compression"}),"\n",(0,t.jsx)(e.li,{children:"Statistics: M=total nodes, I=inputs, L=latches, O=outputs, A=AND gates"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.code,{children:"parse_u64_signal_source(raw: bytes) -> (int, bool)"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Parses 8-byte signal source encoding"}),"\n",(0,t.jsx)(e.li,{children:"Returns node index and inversion flag"}),"\n",(0,t.jsx)(e.li,{children:"Uses big-endian byte order"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.code,{children:"pprint_tnfs_bin(bin: bytes, limit=1024)"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Pretty-prints TNFS binary content in hexadecimal format"}),"\n",(0,t.jsx)(e.li,{children:"Useful for debugging and inspection"}),"\n",(0,t.jsx)(e.li,{children:"Skips padding bytes (0xffffffff patterns)"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Binary Format Structure:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"16-byte chunks representing circuit nodes"}),"\n",(0,t.jsx)(e.li,{children:"Each chunk contains two 8-byte signal sources"}),"\n",(0,t.jsxs)(e.li,{children:["Special patterns identify node types:","\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"0x0000000000000000"})," + ",(0,t.jsx)(e.code,{children:"0x0000000000000000"}),": Header"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"0xffffffffffffffff"})," + ",(0,t.jsx)(e.code,{children:"0xffffffffffffffff"})," with both inverts: Input node"]}),"\n",(0,t.jsxs)(e.li,{children:["First field ",(0,t.jsx)(e.code,{children:"0xffffffffffffffff"}),", invert=false: Output node"]}),"\n",(0,t.jsxs)(e.li,{children:["First field ",(0,t.jsx)(e.code,{children:"0xffffffffffffffff"}),", invert=true: Latch node"]}),"\n",(0,t.jsx)(e.li,{children:"Regular values: AND gate with two inputs"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.h3,{id:"lut-binary-format-load_lut_binpy",children:["LUT Binary Format (",(0,t.jsx)(e.code,{children:"load_lut_bin.py"}),")"]}),"\n",(0,t.jsx)(e.p,{children:"Utilities for loading and parsing LUT (Look-Up Table) binary format files, which represent circuits as lookup tables for efficient FHE execution."}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Key Functions:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.code,{children:"load_lut_bin_stat(bytes) -> statistics"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Analyzes LUT binary format and returns statistics"}),"\n",(0,t.jsx)(e.li,{children:"Counts inputs, outputs, and LUT operations"}),"\n",(0,t.jsx)(e.li,{children:"Does not return AigerGraph (statistics only)"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.code,{children:"parse_row(lhs: int, rhs: int) -> (int, int, int)"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Parses a single LUT row from two 64-bit values"}),"\n",(0,t.jsx)(e.li,{children:"Extracts left/right indices and 4-bit LUT value"}),"\n",(0,t.jsxs)(e.li,{children:["LUT encoding: ",(0,t.jsx)(e.code,{children:"lut = (lut01 << 2) | lut23"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"LUT Format Structure:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"16-byte chunks representing LUT operations"}),"\n",(0,t.jsx)(e.li,{children:"Each chunk contains two 8-byte operands"}),"\n",(0,t.jsx)(e.li,{children:"LUT values encoded in lower 2 bits of each operand"}),"\n",(0,t.jsx)(e.li,{children:"Node indices encoded in upper 62 bits"}),"\n",(0,t.jsx)(e.li,{children:"Special patterns for different node types similar to TNFS format"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"data-flow",children:"Data Flow"}),"\n",(0,t.jsx)(e.h3,{id:"tnfs-binary-processing",children:"TNFS Binary Processing"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Input"}),": Raw binary data (optionally gzip compressed)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Parsing"}),": 16-byte chunks \u2192 node definitions"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Graph Construction"}),": Build NetworkX DiGraph with typed nodes"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Output"}),": AigerGraph + statistics"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"lut-binary-processing",children:"LUT Binary Processing"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Input"}),": Raw binary LUT data"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Parsing"}),": 16-byte chunks \u2192 LUT operations"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Analysis"}),": Count different operation types"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Output"}),": Statistics only (no graph construction)"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,t.jsx)(e.h3,{id:"loading-tnfs-binary",children:"Loading TNFS Binary"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'from pyTNFS.asm_tools.load_tnfs_bin import load_tnfs_bin\n\n# Load compressed TNFS binary\nwith open("circuit.tnfs.gz", "rb") as f:\n    raw_data = f.read()\n\naiger_graph, (total, inputs, latches, outputs, ands) = load_tnfs_bin(raw_data, compression=True)\n\nprint(f"Circuit has {inputs} inputs, {outputs} outputs, {ands} AND gates")\n'})}),"\n",(0,t.jsx)(e.h3,{id:"inspecting-tnfs-binary",children:"Inspecting TNFS Binary"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'from pyTNFS.asm_tools.load_tnfs_bin import pprint_tnfs_bin\n\n# Pretty print first 100 chunks\nwith open("circuit.tnfs", "rb") as f:\n    binary_data = f.read()\n    \npprint_tnfs_bin(binary_data, limit=100)\n'})}),"\n",(0,t.jsx)(e.h3,{id:"analyzing-lut-binary",children:"Analyzing LUT Binary"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'from pyTNFS.asm_tools.load_lut_bin import load_lut_bin_stat\n\nwith open("circuit.lut", "rb") as f:\n    lut_data = f.read()\n\nstats = load_lut_bin_stat(lut_data)\nprint(f"LUT statistics: {stats}")\n'})}),"\n",(0,t.jsx)(e.h2,{id:"binary-format-details",children:"Binary Format Details"}),"\n",(0,t.jsx)(e.h3,{id:"signal-encoding",children:"Signal Encoding"}),"\n",(0,t.jsx)(e.p,{children:"Both formats use a common signal encoding scheme:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Index"}),": Upper bits contain node index"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Invert Flag"}),": LSB indicates whether signal should be inverted"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Special Values"}),": ",(0,t.jsx)(e.code,{children:"0xffffffffffffffff"})," used as sentinel for special node types"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"node-types",children:"Node Types"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Header"}),": Metadata chunk (usually ignored)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Input"}),": Primary input to the circuit"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Output"}),": Primary output from the circuit"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Latch"}),": Sequential element (state storage)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"AND Gate"}),": Combinational logic element with two inputs"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"compression-support",children:"Compression Support"}),"\n",(0,t.jsx)(e.p,{children:"TNFS format supports gzip compression for reduced file sizes, automatically detected and handled by the loader."})]})}function h(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(c,{...n})}):c(n)}},8453:(n,e,s)=>{s.d(e,{R:()=>l,x:()=>o});var i=s(6540);const t={},r=i.createContext(t);function l(n){const e=i.useContext(r);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:l(n.components),i.createElement(r.Provider,{value:e},n.children)}}}]);