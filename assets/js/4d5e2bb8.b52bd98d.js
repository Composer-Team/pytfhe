"use strict";(self.webpackChunkpy_tfhe_oss_doc=self.webpackChunkpy_tfhe_oss_doc||[]).push([[711],{8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>o});var s=r(6540);const i={},t=s.createContext(i);function a(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(t.Provider,{value:n},e.children)}},8847:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"submodules/pytfhe-frontend/benchmark","title":"Benchmark Submodule","description":"The benchmark module provides performance measurement utilities for evaluating FHE (Fully Homomorphic Encryption) operations. It includes both distributed (Ray-based) and serial benchmarking capabilities to measure throughput and latency of various FHE gate operations.","source":"@site/docs/submodules/pytfhe-frontend/benchmark.md","sourceDirName":"submodules/pytfhe-frontend","slug":"/submodules/pytfhe-frontend/benchmark","permalink":"/pytfhe/docs/submodules/pytfhe-frontend/benchmark","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/submodules/pytfhe-frontend/benchmark.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Boolean TFHE Program Runner","permalink":"/pytfhe/docs/submodules/pytfhe-frontend/runner"},"next":{"title":"ChiselTorch","permalink":"/pytfhe/docs/category/chiseltorch"}}');var i=r(4848),t=r(8453);const a={sidebar_position:5},o="Benchmark Submodule",c={},l=[{value:"Core Components",id:"core-components",level:2},{value:"Ray-Based Distributed Benchmarking (<code>ray_benchmark.py</code>)",id:"ray-based-distributed-benchmarking-ray_benchmarkpy",level:3},{value:"Serial Benchmarking (<code>serial_benchmark.py</code>)",id:"serial-benchmarking-serial_benchmarkpy",level:3},{value:"Immediate Generation (<code>bootsCONSTANT</code>)",id:"immediate-generation-bootsconstant",level:4},{value:"NOT Gate (<code>bootsNOT</code>)",id:"not-gate-bootsnot",level:4},{value:"AND Gate (<code>bootsAND</code>)",id:"and-gate-bootsand",level:4},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Distributed Benchmarking",id:"distributed-benchmarking",level:3},{value:"Serial Benchmarking",id:"serial-benchmarking",level:3},{value:"Ray Cluster Benchmarking",id:"ray-cluster-benchmarking",level:3},{value:"Performance Metrics",id:"performance-metrics",level:2},{value:"Throughput Measurement",id:"throughput-measurement",level:3},{value:"Latency Measurement",id:"latency-measurement",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"benchmark-submodule",children:"Benchmark Submodule"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"benchmark"})," module provides performance measurement utilities for evaluating FHE (Fully Homomorphic Encryption) operations. It includes both distributed (Ray-based) and serial benchmarking capabilities to measure throughput and latency of various FHE gate operations."]}),"\n",(0,i.jsx)(n.h2,{id:"core-components",children:"Core Components"}),"\n",(0,i.jsxs)(n.h3,{id:"ray-based-distributed-benchmarking-ray_benchmarkpy",children:["Ray-Based Distributed Benchmarking (",(0,i.jsx)(n.code,{children:"ray_benchmark.py"}),")"]}),"\n",(0,i.jsx)(n.p,{children:"Benchmarks FHE operations using Ray for parallel execution across multiple workers."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Key Function:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ray_benchmark(num: int, num_threads: int = 8)"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Benchmarks AND operations with inversion using distributed workers"}),"\n",(0,i.jsxs)(n.li,{children:["Creates ",(0,i.jsx)(n.code,{children:"num"})," ciphertext pairs (0,1) for testing"]}),"\n",(0,i.jsxs)(n.li,{children:["Uses ",(0,i.jsx)(n.code,{children:"num_threads"})," Ray workers for parallel execution"]}),"\n",(0,i.jsx)(n.li,{children:"Measures total throughput and average operation time"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Workflow:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Setup"}),": Create FHE parameters and secret key"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Data Preparation"}),": Generate ",(0,i.jsx)(n.code,{children:"num"})," ciphertext pairs with values (0,1)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Worker Pool"}),": Initialize Ray worker pool with specified thread count"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Execution"}),": Perform AND-with-invert operations in parallel"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Measurement"}),": Calculate throughput (ops/sec) and average time (\u03bcs)"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Command Line Interface:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"python -m pyTNFS.benchmark.ray_benchmark --num 10000 --num_threads 8 --ray <ray_address>\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Output Metrics:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Throughput"}),": Operations per second"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Average Time"}),": Microseconds per operation"]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"serial-benchmarking-serial_benchmarkpy",children:["Serial Benchmarking (",(0,i.jsx)(n.code,{children:"serial_benchmark.py"}),")"]}),"\n",(0,i.jsx)(n.p,{children:"Benchmarks individual FHE operations in single-threaded mode for baseline performance measurement."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Key Functions:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"benchmark_imm_gen(n: int, bk)"})," - Benchmark immediate value generation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"benchmark_not_gate(n: int, bk)"})," - Benchmark NOT gate operations"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"benchmark_and_gate(n: int, bk)"})," - Benchmark AND gate operations"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Operation Types Benchmarked:"})}),"\n",(0,i.jsxs)(n.h4,{id:"immediate-generation-bootsconstant",children:["Immediate Generation (",(0,i.jsx)(n.code,{children:"bootsCONSTANT"}),")"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Creates ciphertexts with constant values (0 or 1)"}),"\n",(0,i.jsx)(n.li,{children:"Measures time to generate fresh constant ciphertexts"}),"\n",(0,i.jsx)(n.li,{children:"Useful for measuring encryption overhead"}),"\n"]}),"\n",(0,i.jsxs)(n.h4,{id:"not-gate-bootsnot",children:["NOT Gate (",(0,i.jsx)(n.code,{children:"bootsNOT"}),")"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Tests unary NOT operation on encrypted bits"}),"\n",(0,i.jsx)(n.li,{children:"Measures single-input gate performance"}),"\n",(0,i.jsx)(n.li,{children:"In-place operation (output overwrites input)"}),"\n"]}),"\n",(0,i.jsxs)(n.h4,{id:"and-gate-bootsand",children:["AND Gate (",(0,i.jsx)(n.code,{children:"bootsAND"}),")"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Tests binary AND operation between two encrypted bits"}),"\n",(0,i.jsx)(n.li,{children:"Measures two-input gate performance"}),"\n",(0,i.jsx)(n.li,{children:"Most fundamental binary FHE operation"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Measurement Process:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Preparation"}),": Create required ciphertexts and encrypt with random/fixed values"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Timing"}),": Measure wall-clock time for batch operations"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Calculation"}),": Compute average time per operation in microseconds"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Output"}),": Print performance metrics to console"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,i.jsx)(n.h3,{id:"distributed-benchmarking",children:"Distributed Benchmarking"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from pyTNFS.benchmark.ray_benchmark import ray_benchmark\nimport ray\n\n# Initialize Ray cluster\nray.init()\n\n# Benchmark 10,000 AND operations with 8 workers\nray_benchmark(num=10000, num_threads=8)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"serial-benchmarking",children:"Serial Benchmarking"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from pyTNFS.benchmark.serial_benchmark import *\nimport pyTFHE as t\n\n# Setup FHE parameters\nparams = t.new_default_gate_bootstrapping_parameters(110)\nsk = t.new_random_gate_bootstrapping_secret_keyset(params)\nbk = sk.cloud\n\n# Benchmark different operations\nbenchmark_and_gate(1000, bk)      # 1000 AND operations\nbenchmark_not_gate(1000, bk)      # 1000 NOT operations  \nbenchmark_imm_gen(1000, bk)       # 1000 constant generations\n"})}),"\n",(0,i.jsx)(n.h3,{id:"ray-cluster-benchmarking",children:"Ray Cluster Benchmarking"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Connect to existing Ray cluster and run benchmark\npython -m pyTNFS.benchmark.ray_benchmark \\\n    --num 50000 \\\n    --num_threads 16 \\\n    --ray ray://cluster-head:10001\n"})}),"\n",(0,i.jsx)(n.h2,{id:"performance-metrics",children:"Performance Metrics"}),"\n",(0,i.jsx)(n.h3,{id:"throughput-measurement",children:"Throughput Measurement"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Definition"}),": Total operations completed per second"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Calculation"}),": ",(0,i.jsx)(n.code,{children:"num_operations / total_time"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use Case"}),": Measuring parallel execution efficiency"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"latency-measurement",children:"Latency Measurement"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Definition"}),": Average time per individual operation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Units"}),": Microseconds (\u03bcs) for precision"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Calculation"}),": ",(0,i.jsx)(n.code,{children:"total_time / num_operations * 1e6"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use Case"}),": Measuring single operation performance"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);