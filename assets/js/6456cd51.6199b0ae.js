"use strict";(self.webpackChunkpy_tfhe_oss_doc=self.webpackChunkpy_tfhe_oss_doc||[]).push([[8847],{5245:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>u,contentTitle:()=>a,default:()=>o,frontMatter:()=>l,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"submodules/pytfhe-rs/py-bindings","title":"Python Bindings","description":"PyTFHE-rs provides Python bindings via PyO3.","source":"@site/docs/submodules/pytfhe-rs/py-bindings.md","sourceDirName":"submodules/pytfhe-rs","slug":"/submodules/pytfhe-rs/py-bindings","permalink":"/pytfhe/docs/submodules/pytfhe-rs/py-bindings","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/submodules/pytfhe-rs/py-bindings.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"CLI Tools","permalink":"/pytfhe/docs/submodules/pytfhe-rs/cli-tools"},"next":{"title":"Core Modules API Reference","permalink":"/pytfhe/docs/submodules/pytfhe-rs/core-modules"}}');var t=i(4848),r=i(8453);const l={sidebar_position:3},a="Python Bindings",u={},d=[{value:"Installation",id:"installation",level:2},{value:"Prerequisites",id:"prerequisites",level:3},{value:"Setup",id:"setup",level:3},{value:"Verify Installation",id:"verify-installation",level:3},{value:"API Reference",id:"api-reference",level:2},{value:"<code>tnfs.py_greedy_scheduler</code>",id:"tnfspy_greedy_scheduler",level:3},{value:"Signature",id:"signature",level:4},{value:"Parameters",id:"parameters",level:4},{value:"Returns",id:"returns",level:4},{value:"Example",id:"example",level:4},{value:"<code>tnfs.py_lut_greedy_scheduler</code>",id:"tnfspy_lut_greedy_scheduler",level:3},{value:"Signature",id:"signature-1",level:4},{value:"Parameters",id:"parameters-1",level:4},{value:"Returns",id:"returns-1",level:4},{value:"Example",id:"example-1",level:4},{value:"Working with Signal Sources",id:"working-with-signal-sources",level:2},{value:"Complete Examples",id:"complete-examples",level:2},{value:"Basic Circuit Processing",id:"basic-circuit-processing",level:3},{value:"Batch Processing",id:"batch-processing",level:3},{value:"Schedule Analysis",id:"schedule-analysis",level:3},{value:"Integration with NumPy",id:"integration-with-numpy",level:3}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"python-bindings",children:"Python Bindings"})}),"\n",(0,t.jsx)(n.p,{children:"PyTFHE-rs provides Python bindings via PyO3."}),"\n",(0,t.jsx)(n.h2,{id:"installation",children:"Installation"}),"\n",(0,t.jsx)(n.h3,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Python 3.9 or later"}),"\n",(0,t.jsx)(n.li,{children:"Rust toolchain"}),"\n",(0,t.jsx)(n.li,{children:"maturin for building Python extensions"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"setup",children:"Setup"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"# Create conda environment (recommended)\nconda create -n pytfhe python=3.9.13\nconda activate pytfhe\n\n# Install maturin\npip install maturin\n\n# Build and install bindings\ncd pyTFHE-rs\nmaturin develop\n"})}),"\n",(0,t.jsx)(n.h3,{id:"verify-installation",children:"Verify Installation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import tnfs\nprint(tnfs.py_greedy_scheduler)  # Should show function info\nprint(tnfs.py_lut_greedy_scheduler)  # Should show function info\n"})}),"\n",(0,t.jsx)(n.h2,{id:"api-reference",children:"API Reference"}),"\n",(0,t.jsx)(n.h3,{id:"tnfspy_greedy_scheduler",children:(0,t.jsx)(n.code,{children:"tnfs.py_greedy_scheduler"})}),"\n",(0,t.jsx)(n.p,{children:"Generates execution schedules for AIGER circuits using a greedy scheduling algorithm."}),"\n",(0,t.jsx)(n.h4,{id:"signature",children:"Signature"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def py_greedy_scheduler(\n    aig_bytes: bytes, \n    batch_size: int\n) -> List[Tuple[SignalSource, SignalSource, SignalSource]]\n"})}),"\n",(0,t.jsx)(n.h4,{id:"parameters",children:"Parameters"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"aig_bytes"})," (bytes): Binary AIGER circuit data"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"batch_size"})," (int): Batch size for scheduling (currently unused in implementation)"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"returns",children:"Returns"}),"\n",(0,t.jsx)(n.p,{children:"List of tuples representing scheduled AND gate operations:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Each tuple contains ",(0,t.jsx)(n.code,{children:"(output, input1, input2)"})," as ",(0,t.jsx)(n.code,{children:"SignalSource"})," objects"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"SignalSource"})," has fields: ",(0,t.jsx)(n.code,{children:"idx"})," (signal index), ",(0,t.jsx)(n.code,{children:"invert"})," (boolean)"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"example",children:"Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import tnfs\n\n# Read AIGER file\nwith open('circuit.aig', 'rb') as f:\n    aig_data = f.read()\n\n# Generate schedule\nschedule = tnfs.py_greedy_scheduler(aig_data, batch_size=1000)\n\nprint(f\"Generated {len(schedule)} operations\")\nfor i, (output, input1, input2) in enumerate(schedule[:5]):  # Show first 5\n    print(f\"Op {i}: {output.idx}{'!' if output.invert else ''} = \"\n          f\"{input1.idx}{'!' if input1.invert else ''} & \"\n          f\"{input2.idx}{'!' if input2.invert else ''}\")\n"})}),"\n",(0,t.jsx)(n.h3,{id:"tnfspy_lut_greedy_scheduler",children:(0,t.jsx)(n.code,{children:"tnfs.py_lut_greedy_scheduler"})}),"\n",(0,t.jsx)(n.p,{children:"Generates execution schedules for LUT-based circuits."}),"\n",(0,t.jsx)(n.h4,{id:"signature-1",children:"Signature"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def py_lut_greedy_scheduler(\n    lut_bytes: bytes,\n    batch_size: int  \n) -> List[LUTOperation]\n"})}),"\n",(0,t.jsx)(n.h4,{id:"parameters-1",children:"Parameters"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"lut_bytes"})," (bytes): Binary LUT circuit data"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"batch_size"})," (int): Batch size for scheduling"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"returns-1",children:"Returns"}),"\n",(0,t.jsx)(n.p,{children:"List of LUT operations in execution order."}),"\n",(0,t.jsx)(n.h4,{id:"example-1",children:"Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import tnfs\n\n# Read LUT file\nwith open('circuit.lut', 'rb') as f:\n    lut_data = f.read()\n\n# Generate LUT schedule\nlut_schedule = tnfs.py_lut_greedy_scheduler(lut_data, batch_size=500)\n\nprint(f\"Generated {len(lut_schedule)} LUT operations\")\n"})}),"\n",(0,t.jsx)(n.h2,{id:"working-with-signal-sources",children:"Working with Signal Sources"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"SignalSource"})," class represents circuit signals:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# SignalSource properties\nsignal = schedule[0][0]  # First output signal\nprint(f"Signal index: {signal.idx}")\nprint(f"Inverted: {signal.invert}")\n\n# Convert to different representations\nsignal_value = signal.idx * 2 + (1 if signal.invert else 0)\n'})}),"\n",(0,t.jsx)(n.h2,{id:"complete-examples",children:"Complete Examples"}),"\n",(0,t.jsx)(n.h3,{id:"basic-circuit-processing",children:"Basic Circuit Processing"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'import tnfs\nimport sys\n\ndef process_circuit(aig_path):\n    """Process an AIGER circuit and generate execution schedule."""\n    try:\n        # Load circuit\n        with open(aig_path, \'rb\') as f:\n            aig_data = f.read()\n        \n        print(f"Loaded circuit: {len(aig_data)} bytes")\n        \n        # Generate schedule\n        schedule = tnfs.py_greedy_scheduler(aig_data, batch_size=1000)\n        \n        # Analyze schedule\n        print(f"Schedule contains {len(schedule)} operations")\n        \n        # Count unique signals\n        all_signals = set()\n        for output, input1, input2 in schedule:\n            all_signals.add(output.idx)\n            all_signals.add(input1.idx) \n            all_signals.add(input2.idx)\n        \n        print(f"Circuit uses {len(all_signals)} unique signals")\n        \n        return schedule\n        \n    except FileNotFoundError:\n        print(f"Error: Could not find file {aig_path}")\n        return None\n    except Exception as e:\n        print(f"Error processing circuit: {e}")\n        return None\n\nif __name__ == "__main__":\n    if len(sys.argv) != 2:\n        print("Usage: python process_circuit.py <aig_file>")\n        sys.exit(1)\n    \n    schedule = process_circuit(sys.argv[1])\n    if schedule:\n        print("\u2713 Circuit processed successfully")\n'})}),"\n",(0,t.jsx)(n.h3,{id:"batch-processing",children:"Batch Processing"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import tnfs\nimport os\nimport glob\nfrom concurrent.futures import ThreadPoolExecutor\n\ndef process_single_circuit(aig_path):\n    \"\"\"Process a single circuit file.\"\"\"\n    try:\n        with open(aig_path, 'rb') as f:\n            aig_data = f.read()\n        \n        schedule = tnfs.py_greedy_scheduler(aig_data, batch_size=1000)\n        return {\n            'file': aig_path,\n            'operations': len(schedule),\n            'status': 'success'\n        }\n    except Exception as e:\n        return {\n            'file': aig_path,\n            'error': str(e),\n            'status': 'error'\n        }\n\ndef batch_process_circuits(circuit_dir, max_workers=4):\n    \"\"\"Process multiple circuit files in parallel.\"\"\"\n    aig_files = glob.glob(os.path.join(circuit_dir, \"*.aig\"))\n    \n    if not aig_files:\n        print(f\"No .aig files found in {circuit_dir}\")\n        return\n    \n    print(f\"Found {len(aig_files)} circuit files\")\n    \n    with ThreadPoolExecutor(max_workers=max_workers) as executor:\n        results = list(executor.map(process_single_circuit, aig_files))\n    \n    # Summary\n    successful = sum(1 for r in results if r['status'] == 'success')\n    failed = len(results) - successful\n    \n    print(f\"\\nProcessing complete:\")\n    print(f\"\u2713 Successful: {successful}\")\n    print(f\"\u2717 Failed: {failed}\")\n    \n    # Show failed files\n    for result in results:\n        if result['status'] == 'error':\n            print(f\"  Error in {result['file']}: {result['error']}\")\n    \n    return results\n\n# Usage\nif __name__ == \"__main__\":\n    results = batch_process_circuits(\"./test_files\")\n"})}),"\n",(0,t.jsx)(n.h3,{id:"schedule-analysis",children:"Schedule Analysis"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'import tnfs\nfrom collections import defaultdict\n\ndef analyze_schedule(schedule):\n    """Analyze properties of a generated schedule."""\n    if not schedule:\n        print("Empty schedule")\n        return\n    \n    # Signal usage statistics\n    signal_usage = defaultdict(int)\n    invert_count = 0\n    \n    for output, input1, input2 in schedule:\n        signal_usage[output.idx] += 1\n        signal_usage[input1.idx] += 1\n        signal_usage[input2.idx] += 1\n        \n        if output.invert or input1.invert or input2.invert:\n            invert_count += 1\n    \n    print(f"Schedule Analysis:")\n    print(f"  Total operations: {len(schedule)}")\n    print(f"  Unique signals: {len(signal_usage)}")\n    print(f"  Operations with inversions: {invert_count}")\n    \n    # Most used signals\n    top_signals = sorted(signal_usage.items(), key=lambda x: x[1], reverse=True)[:5]\n    print(f"  Most used signals:")\n    for signal_id, usage in top_signals:\n        print(f"    Signal {signal_id}: used {usage} times")\n    \n    # Critical path approximation (simplified)\n    levels = {}\n    for i, (output, input1, input2) in enumerate(schedule):\n        input_level = max(\n            levels.get(input1.idx, 0),\n            levels.get(input2.idx, 0)\n        )\n        levels[output.idx] = input_level + 1\n    \n    max_level = max(levels.values()) if levels else 0\n    print(f"  Estimated circuit depth: {max_level} levels")\n\n# Example usage\nwith open(\'test_files/Adder.aig\', \'rb\') as f:\n    aig_data = f.read()\n\nschedule = tnfs.py_greedy_scheduler(aig_data, batch_size=1000)\nanalyze_schedule(schedule)\n'})}),"\n",(0,t.jsx)(n.h3,{id:"integration-with-numpy",children:"Integration with NumPy"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'import tnfs\nimport numpy as np\n\ndef schedule_to_numpy(schedule):\n    """Convert schedule to NumPy arrays for efficient processing."""\n    n_ops = len(schedule)\n    \n    # Arrays for outputs and inputs\n    outputs = np.zeros((n_ops, 2), dtype=np.int32)  # [idx, invert]\n    input1s = np.zeros((n_ops, 2), dtype=np.int32)\n    input2s = np.zeros((n_ops, 2), dtype=np.int32)\n    \n    for i, (output, input1, input2) in enumerate(schedule):\n        outputs[i] = [output.idx, int(output.invert)]\n        input1s[i] = [input1.idx, int(input1.invert)]\n        input2s[i] = [input2.idx, int(input2.invert)]\n    \n    return outputs, input1s, input2s\n\ndef simulate_with_numpy(schedule, input_values):\n    """Simple simulation using NumPy operations."""\n    outputs, input1s, input2s = schedule_to_numpy(schedule)\n    \n    # Initialize signal values\n    max_signal = max(\n        outputs[:, 0].max(),\n        input1s[:, 0].max(), \n        input2s[:, 0].max()\n    ) + 1\n    \n    signals = np.zeros(max_signal, dtype=bool)\n    \n    # Set input values\n    signals[:len(input_values)] = input_values\n    \n    # Execute operations\n    for i in range(len(schedule)):\n        # Get input values with inversion\n        val1 = signals[input1s[i, 0]] ^ bool(input1s[i, 1])\n        val2 = signals[input2s[i, 0]] ^ bool(input2s[i, 1])\n        \n        # AND operation with output inversion\n        result = (val1 & val2) ^ bool(outputs[i, 1])\n        signals[outputs[i, 0]] = result\n    \n    return signals\n\n# Example\nwith open(\'test_files/Adder.aig\', \'rb\') as f:\n    aig_data = f.read()\n\nschedule = tnfs.py_greedy_scheduler(aig_data, batch_size=1000)\n\n# Simulate with different inputs\ntest_inputs = [True, False, True]  # Example input vector\nfinal_signals = simulate_with_numpy(schedule, test_inputs)\nprint(f"Final signal values: {final_signals}")\n'})})]})}function o(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>a});var s=i(6540);const t={},r=s.createContext(t);function l(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);