"use strict";(self.webpackChunkpy_tfhe_oss_doc=self.webpackChunkpy_tfhe_oss_doc||[]).push([[7249],{5072:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>d,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"submodules/pytfhe-rs/dev-guide","title":"Dev Guide and Architecture","description":"Developer guide of PyTFHE-rs.","source":"@site/docs/submodules/pytfhe-rs/dev-guide.md","sourceDirName":"submodules/pytfhe-rs","slug":"/submodules/pytfhe-rs/dev-guide","permalink":"/pytfhe/docs/submodules/pytfhe-rs/dev-guide","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/submodules/pytfhe-rs/dev-guide.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Core Modules API Reference","permalink":"/pytfhe/docs/submodules/pytfhe-rs/core-modules"},"next":{"title":"PyTFHE-Frontend","permalink":"/pytfhe/docs/category/pytfhe-frontend"}}');var i=s(4848),t=s(8453);const d={sidebar_position:4},a="Dev Guide and Architecture",l={},o=[{value:"Overview",id:"overview",level:2},{value:"Core Components",id:"core-components",level:2},{value:"1. Frontend Layer (<code>src/frontends/</code>)",id:"1-frontend-layer-srcfrontends",level:3},{value:"2. Intermediate Representation (<code>src/ir/</code>)",id:"2-intermediate-representation-srcir",level:3},{value:"Graph IR Node Types",id:"graph-ir-node-types",level:4},{value:"3. Compilation Passes (<code>src/passes/</code>)",id:"3-compilation-passes-srcpasses",level:3},{value:"4. Backend Layer (<code>src/backends/</code>)",id:"4-backend-layer-srcbackends",level:3},{value:"5. Execution Layer (<code>src/runner/</code>)",id:"5-execution-layer-srcrunner",level:3},{value:"Data Flow Architecture",id:"data-flow-architecture",level:2},{value:"1. Parsing Phase",id:"1-parsing-phase",level:3},{value:"2. Analysis Phase",id:"2-analysis-phase",level:3},{value:"3. Optimization Phase",id:"3-optimization-phase",level:3},{value:"4. Code Generation Phase",id:"4-code-generation-phase",level:3},{value:"5. Execution Phase",id:"5-execution-phase",level:3},{value:"Key Design Patterns",id:"key-design-patterns",level:2},{value:"1. Visitor Pattern",id:"1-visitor-pattern",level:3},{value:"2. Builder Pattern",id:"2-builder-pattern",level:3},{value:"3. Strategy Pattern",id:"3-strategy-pattern",level:3},{value:"4. Pipeline Pattern",id:"4-pipeline-pattern",level:3}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"dev-guide-and-architecture",children:"Dev Guide and Architecture"})}),"\n",(0,i.jsx)(n.p,{children:"Developer guide of PyTFHE-rs."}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"PyTFHE-rs is a modular circuit compilation toolchain designed for homomorphic encryption circuits. The system follows a traditional compiler architecture with clear separation between frontend parsing, intermediate representation, optimization passes, and backend code generation."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Frontends  \u2502 -> \u2502      IR      \u2502 -> \u2502   Passes    \u2502 -> \u2502  Backends   \u2502\n\u2502   (Parse)   \u2502    \u2502 (Graph IR)   \u2502    \u2502 (Optimize)  \u2502    \u2502 (Generate)  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       ^                   ^                   ^                   ^\n       \u2502                   \u2502                   \u2502                   \u2502\n   FIRRTL/Yosys      Directed Graph      Optimization        AIGER/LUT\n   Input Files        Representation        Passes           Output Files\n"})}),"\n",(0,i.jsx)(n.h2,{id:"core-components",children:"Core Components"}),"\n",(0,i.jsxs)(n.h3,{id:"1-frontend-layer-srcfrontends",children:["1. Frontend Layer (",(0,i.jsx)(n.code,{children:"src/frontends/"}),")"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Purpose"}),": Parse various hardware description formats into internal IR."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Key Modules"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"firrtl/"})," - FIRRTL parser using tree-sitter grammar"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"yosys/"})," - Yosys JSON and RTLIL support"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Design Principles"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Modular parsers for different input formats"}),"\n",(0,i.jsx)(n.li,{children:"Common IR output regardless of input format"}),"\n",(0,i.jsx)(n.li,{children:"Comprehensive error reporting with source locations"}),"\n",(0,i.jsx)(n.li,{children:"Extensible for new input formats"}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"2-intermediate-representation-srcir",children:["2. Intermediate Representation (",(0,i.jsx)(n.code,{children:"src/ir/"}),")"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Purpose"}),": Central graph-based representation of circuits."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Key Components"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"graph_ir.rs"})," - Main graph data structures"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"infer_type.rs"})," - Type inference system"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"translate.rs"})," - Frontend AST to IR translation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"check.rs"})," - IR validation and consistency checking"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Design Decisions"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Directed Graph"}),": Uses ",(0,i.jsx)(n.code,{children:"petgraph::StableDiGraph"})," for efficient graph operations"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Node-based"}),": Each circuit element is a node with typed connections"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Immutable Operations"}),": Most operations create new nodes rather than modifying existing ones"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Type System"}),": Rich type system supporting bit widths, signs, and special types"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"graph-ir-node-types",children:"Graph IR Node Types"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub enum GraphIRNodeType {\n    Input,                    // Primary inputs\n    Output,                   // Primary outputs\n    Wire,                     // Internal connections\n    Constant(BigInt),         // Literal values\n    Register,                 // Sequential elements\n    Op(PrimOp<NodeIx>),      // Primitive operations\n    Scatter(Vec<NodeIx>),     // Bit decomposition\n    Gather(Vec<NodeIx>),      // Bit composition\n    Inst(Instance),           // Module instantiation\n}\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"3-compilation-passes-srcpasses",children:["3. Compilation Passes (",(0,i.jsx)(n.code,{children:"src/passes/"}),")"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Purpose"}),": Transform and optimize the IR for backend generation."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Pass Types"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Connection Mapping"})," (",(0,i.jsx)(n.code,{children:"connection_map.rs"}),") - Resolve wire connections"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Operation Mapping"})," (",(0,i.jsx)(n.code,{children:"op_map.rs"}),") - Map high-level operations to gates"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Wire Mapping"})," (",(0,i.jsx)(n.code,{children:"wire_map.rs"}),") - Optimize wire usage"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"IO Mapping"})," (",(0,i.jsx)(n.code,{children:"io_map.rs"}),") - Handle input/output interfaces"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Cleanup"})," (",(0,i.jsx)(n.code,{children:"clean.rs"}),") - Remove dead code and optimize"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Gate Generation"})," (",(0,i.jsx)(n.code,{children:"gates_gen.rs"}),") - Generate gate-level implementations"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Pass Pipeline"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Raw IR -> Connection Map -> Op Map -> Wire Map -> IO Map -> Clean -> Gate Gen -> Optimized IR\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"4-backend-layer-srcbackends",children:["4. Backend Layer (",(0,i.jsx)(n.code,{children:"src/backends/"}),")"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Purpose"}),": Generate optimized output formats from IR."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Supported Backends"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"AIGER"})," (",(0,i.jsx)(n.code,{children:"aiger/"}),") - And-Inverter Graph format"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"LUT"})," (",(0,i.jsx)(n.code,{children:"lut/"}),") - Look-Up Table based format"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Common Features"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Binary and ASCII output formats"}),"\n",(0,i.jsx)(n.li,{children:"Compression support"}),"\n",(0,i.jsx)(n.li,{children:"Optimized data structures"}),"\n",(0,i.jsx)(n.li,{children:"Validation and error checking"}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"5-execution-layer-srcrunner",children:["5. Execution Layer (",(0,i.jsx)(n.code,{children:"src/runner/"}),")"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Purpose"}),": Schedule and simulate circuit execution."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Key Components"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"scheduler.rs"})," - Greedy scheduling algorithms"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"lut_scheduler.rs"})," - LUT-specific scheduling"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"simulate/"})," - Simulation engines and support"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"data-flow-architecture",children:"Data Flow Architecture"}),"\n",(0,i.jsx)(n.h3,{id:"1-parsing-phase",children:"1. Parsing Phase"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Input File -> Tree-sitter AST -> Frontend Parser -> FIRRTL IR -> Translation -> Graph IR\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-analysis-phase",children:"2. Analysis Phase"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Graph IR -> Type Inference -> Validation -> Annotated IR\n"})}),"\n",(0,i.jsx)(n.h3,{id:"3-optimization-phase",children:"3. Optimization Phase"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Annotated IR -> Pass 1 -> Pass 2 -> ... -> Pass N -> Optimized IR\n"})}),"\n",(0,i.jsx)(n.h3,{id:"4-code-generation-phase",children:"4. Code Generation Phase"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Optimized IR -> Backend Mapping -> Output Format -> Binary/Text File\n"})}),"\n",(0,i.jsx)(n.h3,{id:"5-execution-phase",children:"5. Execution Phase"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Output Format -> Scheduler -> Execution Order -> Simulation Engine -> Results\n"})}),"\n",(0,i.jsx)(n.h2,{id:"key-design-patterns",children:"Key Design Patterns"}),"\n",(0,i.jsx)(n.h3,{id:"1-visitor-pattern",children:"1. Visitor Pattern"}),"\n",(0,i.jsx)(n.p,{children:"Used extensively for IR traversal:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub trait Visitor<T> {\n    fn visit_node(&mut self, node: &GraphIRNode) -> Result<T, Error>;\n    fn visit_children(&mut self, node: &GraphIRNode) -> Result<Vec<T>, Error>;\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-builder-pattern",children:"2. Builder Pattern"}),"\n",(0,i.jsx)(n.p,{children:"For constructing complex IR structures:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'let mut graph_builder = ModuleGraphBuilder::new();\ngraph_builder\n    .add_input("clk", Type::Clock)\n    .add_input("data", Type::UInt(32))\n    .add_operation(PrimOp::Add(data, constant))\n    .build()\n'})}),"\n",(0,i.jsx)(n.h3,{id:"3-strategy-pattern",children:"3. Strategy Pattern"}),"\n",(0,i.jsx)(n.p,{children:"For different backend implementations:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub trait Backend {\n    type Output;\n    fn generate(&self, ir: &ModuleGraph) -> Result<Self::Output, Error>;\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"4-pipeline-pattern",children:"4. Pipeline Pattern"}),"\n",(0,i.jsx)(n.p,{children:"For compilation passes:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub trait Pass {\n    fn run(&self, ir: &mut ModuleGraph) -> Result<(), PassError>;\n    fn name(&self) -> &str;\n}\n\npub struct PassManager {\n    passes: Vec<Box<dyn Pass>>,\n}\n"})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>d,x:()=>a});var r=s(6540);const i={},t=r.createContext(i);function d(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);